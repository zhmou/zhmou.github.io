<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信号与系统——傅里叶变换公式的推导</title>
    <url>/2020/10/25/Signals-Systems-Fourier/</url>
    <content><![CDATA[<p><strong>本文内嵌有大量的数学符号、公式，为确保排版格式正确，推荐您使用电脑端查看这篇文章。</strong></p>
<p>对于在时域上满足<strong>一定条件</strong>的信号f(t)，我们可以通过傅里叶变换的公式将其转化为频域上的信号F(jω)：<br>
$$<br>
F(j\omega)=\int_{-\infty}^{+\infty}f(t)e^{-j\omega t}dt<br>
$$<br>
同时也可以通过傅里叶反变换的公式将其还原为时域上的信号：<br>
$$<br>
f(t)=\frac1{2\pi}\int_{-\infty}^{+\infty}F(j\omega )e^{j\omega t}dt<br>
$$<br>
通过这个数学工具，我们建立起了两个不同的角度间描述同一个信号的桥梁。而笔者在复习《信号与系统》的过程中，深刻认识到了它的重要性，因此决定记录下它的推导过程以加深理解。</p>
<span id="more"></span>
<h2 id="时域？频域？"><a class="header-anchor" href="#时域？频域？"></a>时域？频域？</h2>
<p><strong>时域</strong>是描述一个数学函数或者物理信号对时间的关系。在中学物理中，我们就知道声音的本质是物体振动所产生的波，就如同正弦波$f(x)=Asin(x+\phi)$那样，不过这里的自变量变成了时间$t$。在给定任意一个时间$t$的情况下，你都可以用函数表达式计算得到它的幅度与相位信息，即$f(t)$。</p>
<p><img data-src="/img/2020-10-25-Signals-Systems-Fourier/01.jpg" alt="时域与频域"></p>
<p>在时域波形中，我们很容易进行两种基础的操作：通过改变$A$的值以改变振幅——换一个说法，你改变了音量的大小；或者改变$x$前的系数以改变频率，这样就改变了音乐的播放速度。</p>
<p>然而，如果音频中出现了不需要的噪声、又或者一首歌曲中，我们想要加强低音部分的人声又该如何处理呢？仅仅依靠时域繁复的波形图难以解决这些问题——因此我们需要引入另一个视角：<strong>频域</strong>。</p>
<p>世间千变万化的物质，其分子的组成都能在一张元素周期表上找到；红黄蓝三种色彩，却能绘出五彩斑斓的世界；而一首优美动人的歌曲，在简谱上呈现出来的只是几个数字。这种记谱符号正是我们从频域看待音乐的角度，例如音阶A4（即中央C上的A，唱名“la”（啦））就是440Hz的标准音高。同时域类似，<strong>频域</strong>是描述一个信号在不同频率上的关系，它改变了我们看待问题的视角：</p>
<img data-src="/img/2020-10-25-Signals-Systems-Fourier/02.jpg" alt="tvf" style="zoom:50%;" />
<p>一个在时间轴上显得“混乱不堪”的信号，在频域里则清晰明了。而上文所述的一些操作在频域中也是随手拈来：滤除噪声？去掉噪声所在频率的分量，加强低音？提升音乐的低频分量就好了，不是吗？</p>
<h2 id="正交又是啥玩意儿？"><a class="header-anchor" href="#正交又是啥玩意儿？"></a>正交又是啥玩意儿？</h2>
<p>同样是中学时代，我们学会了将力这一矢量（向量）进行<strong>正交</strong>分解，分解到两个<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>相互<strong>正交</strong>的方向上。在这个时候，正交就是（向量的）垂直。在三维空间中，正交依然意味着垂直的关系，但处在更高维度中，“垂直”的几何关系我们没有直接手段观测测量，我们又是如何理解的呢？</p>
<p>好在数学家们能够用数学手段去描述这种垂直——那就是内积（点积）。<br>
$$<br>
\begin{gathered}<br>
\vec v_1 = \left[ \begin{matrix} x_1 \\ y_1 \end{matrix} \right]<br>
\quad<br>
\vec v_2 = \left[ \begin{matrix} x_2 \\ y_2 \end{matrix} \right]<br>
\end{gathered}<br>
$$<br>
对于$\vec v_1$和$\vec v_2$这两个二维向量而言，内积的代数表达式为$\vec v_1\cdot\vec v_2 = x_1x_2 + y_1y_2$，而从几何的角度来看，内积的表达式为$\vec v_1\cdot\vec v_2 = \mid\vec v_1\mid\mid\vec v_2\mid\cos\theta$，这个运算可以理解为一个向量的模乘以另一个向量投影的模。当两向量垂直时，$cos\theta=cos90^\circ=0$，因此内积为0。啊哈，垂直就是两向量内积为0的特殊情况！</p>
<p>而正交就是对这种内积为0情形的抽象概括。一般的，对于任意两个n维实向量$\vec a$、$\vec b$，<br>
$$<br>
\begin{gathered}<br>
\vec a = \left[ \begin{matrix} a_1 \\ a_2 \\ \vdots \\ a_n \end{matrix} \right]<br>
\quad<br>
\vec b = \left[ \begin{matrix} b_1 \\ b_2 \\ \vdots \\ b_n \end{matrix} \right]<br>
\end{gathered}<br>
$$<br>
有$\vec a\cdot\vec b = a_1b_1 + a_2b_2 + \cdots + a_nb_n = \sum_{i=1}^{\infty}a_ib_i$，若其内积为0，则称这两个向量是正交的。</p>
<p>现在，我们再来对<strong>内积</strong>这个概念进行推广。对于两个在区间$[a,b]$上的实变函数$f(x)$和$g(x)$，假设将其分割成宽度为$\Delta x$的若干子区间。考虑存在这样两个向量：<br>
$$<br>
\begin{gathered}<br>
\vec f = \left[ \begin{matrix} f(a) \\ f(\Delta x) \\ \vdots \\ f(a+k\Delta x) \end{matrix} \right]<br>
\quad<br>
\vec g = \left[ \begin{matrix} g(a) \\ g(\Delta x) \\ \vdots \\ g(a+k\Delta x) \end{matrix} \right]<br>
\end{gathered}<br>
$$<br>
则其内积：</p>
<p>$\vec f\cdot\vec g = f(a)g(a)\Delta x + f(\Delta x)g(\Delta x)\Delta x + \cdots + f(a+k\Delta x)g(a+k\Delta x)\Delta x = \sum_{i=1}^{k}f(a+i\Delta x)g(a+i\Delta x)\Delta x$<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
<p>当$\Delta x\rightarrow0$时，就得到了函数内积的表达式$f(x){\cdot}g(x) = \int_a^bf(x)g(x)dx$。类比向量的正交，当积分的结果为0时，我们可以说这两个函数<strong>在区间$[a,b]$上正交</strong>。</p>
<p>实际上，函数之所以能和向量进行类比是因为函数也具有向量的性质：</p>
<p>函数相加类比向量的加法：<br>
$$<br>
f+g=\left[ \begin{matrix} f(x_1) \\ f(x_2) \\ \vdots \\ f(x_n)  \end{matrix} \right]+<br>
\left[ \begin{matrix} g(x_1) \\ g(x_2) \\ \vdots \\ g(x_n)  \end{matrix} \right] = \left[ \begin{matrix} f(x_1)+g(x_1) \\ f(x_2)+g(x_2) \\ \vdots \\ f(x_n)+g(x_n)  \end{matrix} \right]<br>
$$<br>
函数与实数相乘对应向量的数乘：<br>
$$<br>
af=a\left[ \begin{matrix} f(x_1) \\ f(x_2) \\ \vdots \\ f(x_n)  \end{matrix} \right] = \left[ \begin{matrix} af(x_1) \\ af(x_2) \\ \vdots \\ af(x_n)  \end{matrix} \right]<br>
$$<br>
因而从某种意义上说，函数也可以抽象为向量看待。在此，我推荐3Blue1Brown的<a href="https://www.bilibili.com/video/BV1ps41147Z5">这个视频</a>来更直观地展现向量与函数的相似性以及对<em>向量是什么</em>这个问题的回答。</p>
<p>但是还没完呢！我们还能将<strong>正交、内积</strong>的概念继续向复平面里的向量与复函数推广，在复平面中，我们把内积<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>定义为：<br>
$$<br>
&lt;\vec x,\vec y&gt;=\sum_{i=1}^n x_i{y_i}^*<br>
$$<br>
即前者向量中的各元素乘以后者向量中各元素的共轭（即虚部取反）<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p>
<p>同样的，复向量的内积同样可以推广到复函数上：<br>
$$<br>
&lt;f,g&gt;=\int_a^bf(t)\overline{g(t)}dt<br>
$$<br>
而正交，同样是这些内积为0的特殊情况。至此，我们已经详细介绍了内积与正交的基础知识，它们很快就将应用到下一节的学习中。</p>
<h2 id="三角傅里叶级数"><a class="header-anchor" href="#三角傅里叶级数"></a>三角傅里叶级数</h2>
<h3 id="引入"><a class="header-anchor" href="#引入"></a>引入</h3>
<p>对于任意一个多项式函数，我们可以发现<em>堆砌组成</em>它的<em>原材料</em>是$\mathbb \{1,x,x^2,...,x^n\}$。譬如多项式$y=x^3+3x^2+2x$，它由1个$x^3$，3个$x^2$和2个$x$构成。<br>
<img data-src="/img/2020-10-25-Signals-Systems-Fourier/03.jpg" alt="多项式函数的组成"><br>
就如同厨师烧菜一样，在知道了配方中每一项<em>原材料</em>系数的情况下，就可以还原出一道美味来。甚至借助于这些幂函数，在满足一定条件的前提下，我们可以在某点邻域内无限逼近另一些非多项式函数。<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></p>
<p>向量中也有如出一辙的想法。选定两个正交<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup>的向量，通过线性组合可以构成整个平面（二维）空间中的任意一个向量。如图所示，选定x、y坐标轴方向上的彼此正交的两个单位向量$\vec u$、$\vec v$来表示$\vec w$：</p>
<p><img data-src="/img/2020-10-25-Signals-Systems-Fourier/04.png" alt="例子"><br>
$$<br>
\vec w = 5\vec u + 3\vec v<br>
$$<br>
在上一节中，我们提到函数与向量的相似性。借着这样一个思路，我们不禁考虑：是否能找出一组在某个区间上彼此正交的函数，使得定义在该区间上的其他函数也能被正交函数的线性组合所表示呢？</p>
<p>答案是肯定的，如同二维平面空间中的任意一个向量可由两个正交向量表示，三维空间中的向量由三个两两正交的向量一样。类比为无穷多维向量的函数自然需要无穷个彼此正交的函数表示。这些构建起复杂函数的基石被我们称作<strong>正交函数族（集）</strong>。</p>
<p>不难证明，以下这些函数在区间$[-\pi,\pi]$上是彼此正交的：<br>
$$<br>
\mathbb \{1,sin\ x,sin\ 2x,...,sin\ nx,..., cos\ x,cos\ 2x,...,cos\ nx\}<br>
$$<br>
证明如下：</p>
<p>对于1与余弦或正弦函数之间的正交性：<br>
$$<br>
\begin{align*}<br>
&amp;\int_{-\pi}^{\pi}1\cdot{cos\ nxdx} = {sin\ nx\over n} =0\\<br>
&amp;\int_{-\pi}^{\pi}1\cdot{sin\ nxdx} = -{cos\ nx\over n} =0<br>
\end{align*}<br>
$$<br>
三角函数之间的正交性：<br>
$$<br>
\begin{align*}<br>
&amp;\int_{-\pi}^{\pi}cos \ nx\cdot{sin\ mxdx} = {1\over2}\int_{-\pi}^{\pi}[sin \ (m+n)x+{sin\ (m-n)x]dx}=0 \\<br>
&amp;\int_{-\pi}^{\pi}cos \ nx\cdot{cos\ mxdx} = {1\over2}\int_{-\pi}^{\pi}[cos \ (n+m)x+{cos\ (n-m)x]dx}=0,m\not=n\\<br>
&amp;\int_{-\pi}^{\pi}sin \ nx\cdot{sin\ mxdx} = {1\over2}\int_{-\pi}^{\pi}[cos \ (n-m)x-{cos\ (n+m)x]dx}=0,m\not=n<br>
\end{align*}<br>
$$</p>
<p>经过压缩或者拉伸，上述函数在区间$[-{T\over2},{T\over2}]$同样是彼此正交的：<br>
$$<br>
\mathbb \{1,sin\ \Omega x,sin\ 2\Omega x,...,sin\ n\Omega x,..., cos\ \Omega x,cos\ 2\Omega x,...,cos\ n\Omega x\},\ 其中\Omega ={2\pi\over T}<br>
$$<br>
因此，对于同样定义在区间$[-{T\over2},{T\over2}]$上的函数$f(x)$，我们便可以考虑写作以上这些正交函数的线性组合。而这种展开形式的猜想，即<strong>任何连续周期信号可以由一组适当的正弦曲线组合而成</strong>，最早由法国科学家<strong>傅里叶</strong>提出，因此我们将这种展开式称作<strong>三角傅里叶级数</strong>。<br>
$$<br>
f(x)=B_0+\sum_{n=1}^\infty(a_ncos\ n\Omega x+b_nsin\ n\Omega x)<br>
$$<br>
我们突破了小小的一步，但是更为关键的问题是，如何计算这些系数呢？</p>
<h3 id="计算"><a class="header-anchor" href="#计算"></a>计算</h3>
<p><strong>几何思路</strong></p>
<p>兜兜转转，我们又回到了直观的几何上。仍以上面的$\vec u$、$\vec v$、$\vec w$为例，计算一个$\vec w$需要多少$\vec u$和$\vec v$就是计算投影在相应向量上的倍数：</p>
<p><img data-src="/img/2020-10-25-Signals-Systems-Fourier/05.png" alt="投影"></p>
<p>如图所示，假设$\vec w$投影于$\vec u$上的向量$\vec w_1=\lambda\vec u$，则$\vec w-\lambda\vec u = \vec{DE}$，而这个向量垂直于$\vec u$。也就是说$&lt;\vec u,\vec w-\lambda\vec u&gt;=0$，对线性代数稍有了解的人就能计算出：<br>
$$<br>
\begin{align*}<br>
&amp;{\vec u}^T(\vec w-\lambda\vec u)=0\\<br>
&amp;\lambda={ {\vec u}^T\vec w\over\vec u^T\vec u}={&lt;\vec u,\vec w&gt;\over&lt;\vec u,\vec u&gt;}<br>
\end{align*}<br>
$$<br>
就这样，正交向量的系数就以内积的形式表达出来。依此类推，函数内积的系数也可以被我们表达出来。</p>
<p>$B_0$是$f(t)$在1上的<em>投影</em>：<br>
$$<br>
B_0 = {\int_{-{T\over2} }^{T\over2}1\cdot f(t)dt\over\int_{-{T\over2} }^{T\over2}1\cdot 1dt}={1\over T}\int_{-{T\over2} }^{T\over2} f(t)dt<br>
$$<br>
$a_n$是$f(t)$在$cos\ n\Omega t$上的<em>投影</em>：<br>
$$<br>
a_n = {\int_{-{T\over2} }^{T\over2}cos\ n\Omega t\cdot f(t)dt\over\int_{-{T\over2} }^{T\over2}cos^2n\Omega tdt}={2\over T}\int_{-{T\over2} }^{T\over2} f(t)cos\ n\Omega tdt<br>
$$<br>
(分母的计算：$\int_{-{T\over2} }^{T\over2}cos^2n\Omega tdt = {1\over2}\int_{-{T\over2} }^{T\over2}(2cos^2n\Omega t-1)dt+{1\over2}\int_{-{T\over2} }^{T\over2}1\ dt={T\over2}$)</p>
<p>$b_n$是$f(t)$在$sin\ n\Omega t$上的<em>投影</em>:<br>
$$<br>
b_n = {\int_{-{T\over2} }^{T\over2}sin\ n\Omega t\cdot f(t)dt\over\int_{-{T\over2} }^{T\over2}sin^2n\Omega tdt}={2\over T}\int_{-{T\over2} }^{T\over2} f(t)sin\ n\Omega tdt\\<br>
$$<br>
分母的计算与上面相似，不再赘述。</p>
<p><strong>积分思路</strong></p>
<p>对于等式$f(t)=A_0+\sum_{n=1}^\infty(a_ncos\ n\Omega t+b_nsin\ n\Omega t)$，将其逐项对$[-{T\over2},{T\over2}]$进行积分，有</p>
<p>$$<br>
\begin{align*}<br>
\int_{-{T\over2} }^{T\over2} f(t)dt &amp;= TB_0+\sum_{n=1}^\infty(a_n\int_{-{T\over2} }^{T\over2}cos\ n\Omega tdt+b_n\int_{-{T\over2} }^{T\over2}sin\ n\Omega tdt)\\<br>
&amp;由三角函数的正交性可知，后面积分项的值为0\\<br>
&amp;=TB_0\\<br>
故B_0&amp;={1\over T}\int_{-{T\over2} }^{T\over2} f(t)dt<br>
\end{align*}<br>
$$</p>
<p>若在等式两侧同时乘以$cos\ m\Omega t$再进行积分，则有</p>
<p>$$<br>
\int_{-{T\over2} }^{T\over2} f(t)cos\ m\Omega tdt = B_0\int_{-{T\over2} }^{T\over2}cos\ m\Omega tdt+\sum_{n=1}^\infty(a_n\int_{-{T\over2} }^{T\over2}cos\ n\Omega t\cdot cos\ m\Omega tdt+b_n\int_{-{T\over2} }^{T\over2}sin\ n\Omega t\cdot cos\ m\Omega tdt)<br>
$$</p>
<p>由三角函数的正交性，<br>
$$<br>
\begin{align*}<br>
&amp;\int_{-{T\over2} }^{T\over2}cos\ m\Omega tdt = 0\\<br>
&amp;\int_{-{T\over2} }^{T\over2}cos\ n\Omega t\cdot cos\ m\Omega tdt = 0(n\not=m)\\<br>
&amp;\int_{-{T\over2} }^{T\over2}sin\ n\Omega t\cdot cos\ m\Omega tdt=0<br>
\end{align*}<br>
$$</p>
<p>而n = m时，有</p>
<p>$$<br>
\begin{align*}<br>
&amp;\int_{-{T\over2} }^{T\over2}cos^2n\Omega tdt = {T\over2}\\<br>
故&amp;\int_{-{T\over2} }^{T\over2} f(t)cos\ m\Omega tdt = a_n\cdot {T\over2}\\<br>
&amp;a_n={2\over T}\int_{-{T\over2} }^{T\over2} f(t)cos\ n\Omega tdt<br>
\end{align*}<br>
$$</p>
<p>同理，在等式两侧乘以$sin\ m\Omega t$再积分可得$b_n$，此处略去具体过程，直接给出结果。</p>
<p>$$<br>
b_n = {2\over T}\int_{-{T\over2} }^{T\over2} f(t)sin\ n\Omega tdt<br>
$$</p>
<p><strong>小结</strong></p>
<p>现在让我们再重复一次所得到的结果：<br>
$$<br>
\begin{align*}<br>
&amp;f(t)=B_0+\sum_{n=1}^\infty(a_ncos\ n\Omega x+b_nsin\ n\Omega x)\\<br>
&amp;其中:\\<br>
&amp;B_0 = {1\over T}\int_{-{T\over2} }^{T\over2} f(t)dt\\<br>
&amp;a_n ={2\over T}\int_{-{T\over2} }^{T\over2} f(t)cos\ n\Omega tdt\\<br>
&amp;b_n = {2\over T}\int_{-{T\over2} }^{T\over2} f(t)sin\ n\Omega tdt<br>
\end{align*}<br>
$$<br>
考虑到$B_0 = 2a_0$，于是傅里叶级数可写作：<br>
$$<br>
f(t)={a_0\over2}+\sum_{n=1}^\infty(a_ncos\ n\Omega t+b_nsin\ n\Omega t)<br>
$$</p>
<p>继续&amp;合并同频率的三角函数，又可以得到：<br>
$$<br>
\begin{align*}<br>
f(t)&amp;={a_0\over2}+\sum_{n=1}^\infty\sqrt{ {a_n}^2+{b_n}^2}(cos\ n\Omega t\cdot {a_n\over\sqrt{ {a_n}^2+{b_n}^2}}-sin\ n\Omega t\cdot {-b_n\over\sqrt{ {a_n}^2+{b_n}^2}})\\<br>
&amp;={a_0\over2}+\sum_{n=1}^\infty A_ncos(n\Omega t + \phi_n)\\<br>
其中A_n&amp;=\sqrt{ {a_n}^2+{b_n}^2}\\<br>
\phi_n&amp;=-arctan({b_n\over a_n})\\<br>
\end{align*}<br>
$$<br>
(根据$a_{-n} = a_n,b_{-n}=-b_n$，可以得知$A_{-n}=A_n,\phi_{-n}=-\phi_n$,这一结论将帮助我们推导下一小节的内容)</p>
<p>其中$a_n$、$b_n$被称作<strong>傅里叶系数</strong>现在，我们可以用不同频率、相位、强度的<em>原材料</em>——余弦函数的叠加来逼近定义在$[-{T\over2},{T\over2}]$区间上的一些函数啦！咦？余弦函数具有周期性，那么叠加出来的函数同样具有周期性呢！所以，我们得出了这样一个结论：</p>
<div style="text-align:center;"><font color = red size = 5>周期函数可由一个序列的正弦（余弦）型函数叠加得到。</font></div>
<p>来试试看吧！以下就是用一组正弦函数叠加得到的周期函数$y = x(-\pi&lt;x&lt;\pi)$，其傅里叶展开式为$2\sum_{n=1}^\infty{(-1)}^{n-1}{sin\ nx\over n}$</p>
<p><img data-src="/img/2020-10-25-Signals-Systems-Fourier/06.jpg" alt="叠加"></p>
<p>我们可以看到，当n仅仅取到5时，所得到的结果就比较趋近于锯齿波了。看来，“我们的研究成果”还是挺有用的。</p>
<p>附：绘图用的Matlab代码</p>
<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">t = <span class="number">-3</span>*<span class="built_in">pi</span>:<span class="number">0.01</span>:<span class="number">3</span>*<span class="built_in">pi</span>;</span><br><span class="line">y = <span class="built_in">pi</span>*sawtooth(t-<span class="built_in">pi</span>);</span><br><span class="line">y1 = <span class="number">2</span>*(<span class="built_in">sin</span>(t));</span><br><span class="line">y2 = <span class="number">2</span>*(<span class="built_in">sin</span>(t) - (<span class="built_in">sin</span>(<span class="number">2</span>*t))/<span class="number">2</span>);</span><br><span class="line">y3 = <span class="number">2</span>*(<span class="built_in">sin</span>(t) - (<span class="built_in">sin</span>(<span class="number">2</span>*t))/<span class="number">2</span>+(<span class="built_in">sin</span>(<span class="number">3</span>*t))/<span class="number">3</span>);</span><br><span class="line">y4 = <span class="number">2</span>*(<span class="built_in">sin</span>(t) - (<span class="built_in">sin</span>(<span class="number">2</span>*t))/<span class="number">2</span>+(<span class="built_in">sin</span>(<span class="number">3</span>*t))/<span class="number">3</span>-(<span class="built_in">sin</span>(<span class="number">4</span>*t))/<span class="number">4</span>);</span><br><span class="line">y5 = <span class="number">2</span>*(<span class="built_in">sin</span>(t) - (<span class="built_in">sin</span>(<span class="number">2</span>*t))/<span class="number">2</span>+(<span class="built_in">sin</span>(<span class="number">3</span>*t))/<span class="number">3</span>-(<span class="built_in">sin</span>(<span class="number">4</span>*t))/<span class="number">4</span>+(<span class="built_in">sin</span>(<span class="number">5</span>*t))/<span class="number">5</span>);</span><br><span class="line">a = subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>);<span class="built_in">plot</span>(a,t,y);title(<span class="string">&#x27;y=x&#x27;</span>)</span><br><span class="line">b = subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">2</span>);<span class="built_in">plot</span>(b,t,y1);title(<span class="string">&#x27;y=2sinx&#x27;</span>)</span><br><span class="line">c = subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>);<span class="built_in">plot</span>(c,t,y2);title(<span class="string">&#x27;y=2(sinx-sin2x/2)&#x27;</span>)</span><br><span class="line">d = subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>);<span class="built_in">plot</span>(d,t,y3);title(<span class="string">&#x27;y=2(sinx-sin2x/2+sin3x/3)&#x27;</span>)</span><br><span class="line">e = subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>);<span class="built_in">plot</span>(e,t,y4);title(<span class="string">&#x27;y=2(sinx-sin2x/2+sin3x/3-sin4x/4)&#x27;</span>)</span><br><span class="line">f = subplot(<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>);<span class="built_in">plot</span>(f,t,y5);title(<span class="string">&#x27;y=2(sinx-sin2x/2+sin3x/3-sin4x/4+sin5x/5)&#x27;</span>)</span><br><span class="line">axis([a b c d e f],[<span class="number">-10</span> <span class="number">10</span> <span class="number">-4</span> <span class="number">4</span>])</span><br></pre></td></tr></table></figure>
<h2 id="欧拉公式与指数傅里叶级数"><a class="header-anchor" href="#欧拉公式与指数傅里叶级数"></a>欧拉公式与指数傅里叶级数</h2>
<p>借助于欧拉公式$e^{ix}=cosx+isinx$，我们可以得到$cosx={1\over2}(e^{ix}+e^{-ix})$。</p>
<p>将上一节中得到的$f(t)$进行变形——<br>
$$<br>
\begin{align*}<br>
f(t)&amp;={a_0\over2}+\sum_{n=1}^\infty A_ncos(n\Omega t + \phi_n)\\<br>
&amp;={a_0\over2}+{1\over2}\sum_{n=1}^\infty A_n[e^{j(n\Omega t + \phi_n)}+e^{-j(n\Omega t + \phi_n)}]\cdots 信息学中常用j表示虚数，避免与电流i混淆。\\<br>
&amp;={a_0\over2}+{1\over2}\sum_{n=1}^\infty A_ne^{j(n\Omega t + \phi_n)}+A_{-n}e^{ {j[(-n)\Omega t}+\phi_{-n}] }\cdots 利用上一节中给出的A_n与\phi_n的奇偶性。\\<br>
&amp;={a_0\over2}+{1\over2}[\sum_{n=1}^\infty A_ne^{j(n\Omega t + \phi_n)}+\sum_{n=-1}^{-\infty} A_ne^{j(n\Omega t + \phi_n)}]\\<br>
&amp;=\sum_{n=-\infty}^\infty {1\over2}A_ne^{j(n\Omega t + \phi_n)}\cdots A_0 = a_0, \phi_0 = 0<br>
\end{align*}<br>
$$<br>
这样，我们又得到了一个以${1,e^{j\Omega t},e^{2j\Omega t},...e^{nj\Omega t},...}$为正交函数集的傅里叶级数，我们把它叫做<strong>指数傅里叶级数</strong>。</p>
<p>它的<strong>傅里叶系数</strong>$\dot F_n$为复函数的形式，表达式为：<br>
$$<br>
\begin{align*}<br>
\dot F_n &amp;= {1\over2}A_n e^{j\phi_n}\\<br>
&amp;= {1\over2}(A_ncos\phi_n+jA_nsin\phi_n)={1\over2}(a_n-jb_n)\\<br>
&amp;= {1\over T}\int_{-{T\over2} }^{T\over2} f(t)(cos\ n\Omega t - jsin\ n\Omega t)dt\\<br>
&amp;= {1\over T}\int_{-{T\over2} }^{T\over2} f(t)e^{-jn\Omega t}dt<br>
\end{align*}<br>
$$<br>
<strong>注意</strong>那个$e^{-jn\Omega t}$上的负号！从计算内积的方法来看，函数与$e^{jn\Omega t}$的内积恰好是后者取共轭，所以这和三角傅里叶展开的思路是一致的。</p>
<p>将$e^{j\phi_n}$用欧拉公式展开，这个复矢量的<em>活动轨迹</em>就是复平面上的单位圆，因此$\dot F_n$也可写作模与幅角的形式：$\dot F_n=|F_n|e^{j\phi_n}$。</p>
<h2 id="从周期到非周期——T→∞"><a class="header-anchor" href="#从周期到非周期——T→∞"></a>从周期到非周期——T→∞</h2>
<p>非周期的信号不能用傅里叶级数来表示，但是可以利用相同的思路进行一样的分析。当周期$T$无限增大时，周期信号就能转化成非周期的单脉冲信号。而展开的一组正弦（余弦）信号之间频率的差值$\Omega$就越小——直到离散的频率分量变得连续。对上一节中的$\dot F_n$进行分析，当$T\rightarrow\infty$时，傅里叶系数趋于0，然而将上式两边同乘以$T$，它就变成了$\omega$<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup>相关的一个函数——$F(j\omega)$，取极限可得到$\lim_{T\rightarrow\infty}\dot F_nT=\lim_{\Omega\rightarrow0}2\pi\dot {F_n\over \Omega}$，$\dot {F_n\over \Omega}$表示了某个单位频率带宽内信号的强度（频谱值），因此称之为频谱密度函数——简称频谱函数。现在，我们终于推得了开头写下的第一个式子：<br>
$$<br>
F(j\omega)=\lim_{T\rightarrow\infty}\dot F_nT=\int_{-\infty}^{+\infty}f(t)e^{-j\omega t}dt<br>
$$<br>
反过来，对于$f(t)$的指数傅里叶级数展开<br>
$$<br>
\begin{align*}<br>
f(t)&amp;=\sum_{n=-\infty}^\infty {1\over2}A_ne^{j(n\Omega t + \phi_n)}\\<br>
&amp;=\sum_{n=-\infty}^\infty \dot F_ne^{jn\Omega t}\\<br>
&amp;=\sum_{n=-\infty}^\infty \dot {F_n\over\Omega}e^{jn\Omega t}\Omega\\<br>
\end{align*}<br>
$$<br>
当$T\rightarrow\infty$时，相邻频率的间隔由$\Omega变为d\omega$,而离散分立的频率$n\Omega$变为了$\omega$,无穷多项求和转化为了积分，于是有：<br>
$$<br>
f(t)=\int_{-\infty}^{+\infty}{F(j\omega )\over2\pi}e^{j\omega t}dt=\frac1{2\pi}\int_{-\infty}^{+\infty}F(j\omega )e^{j\omega t}dt<br>
$$</p>
<p>以上，就是推出的第二个式子。基于这两个积分，我们可以做出$f(t)\leftrightarrow F(j\omega)$的相互转换，前者就是<strong>傅里叶变换</strong>，而后者我们称为<strong>傅里叶反变换</strong>，从而在时间域的视角与频率域的视角间相互转换，将一些复杂的操作简单化。</p>
<h2 id="总结"><a class="header-anchor" href="#总结"></a>总结</h2>
<p>在傅里叶变换与反变换的基础上，结合其在频域实际的物理意义，在连续时间系统上有着广泛的应用——从简化求解电路的微分方程，到通信基础技术：调制与解调，它是变换域分析法的基石。在下期之中——如果有的话——我们会探讨这一变换的性质，以及给出常见信号的傅里叶变换对，甚至我们还可以研究它的在生活中的实际应用。啊~不知你是否看见了我在第一句话里提到的<strong>一定条件</strong>呢？没错，它也是不是放之四海而皆准、对任意信号都能使用的方法，这为下一个变换域的诞生埋下了伏笔，我们会在更远的将来提到它。</p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>中学物理一般只考察力在二维平面的分解 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>$\Delta x$可看作子区间的<strong>权重</strong>，实际上$f(a)$与$g(a)$代表了$[a,a+\Delta x]$这段子区间上所有函数的值，因此在每一项后面乘以$\Delta x$ <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>此处指Hermitian inner product，厄米特内积。 <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn4" class="footnote-item"><p>这样定义的一大目的是使得一个向量与自己的内积——几何意义上而言——向量模的平方是个正<strong>实数</strong>（满足正定性）。 <a href="#fnref4" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn5" class="footnote-item"><p>指泰勒公式展开，一定条件：带佩亚诺余项的n阶泰勒公式要求展开点处n阶可导。 <a href="#fnref5" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn6" class="footnote-item"><p>实际上，任意n个线性无关的n维向量都能张成n维空间，我们选取正交因为它具有更好的性质。 <a href="#fnref6" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn7" class="footnote-item"><p>离散分立的频率用大写希腊字母$n\Omega$表示，连续的频率用小写希腊字母$\omega$表示，实际上含义是一致的。 <a href="#fnref7" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>信号与系统</tag>
      </tags>
  </entry>
  <entry>
    <title>配置SOLOV2_ncnn相关环境并运行Demo</title>
    <url>/2021/10/09/Configure-a-NCNN-Project/</url>
    <content><![CDATA[<p>  今天最开心的事情是终于在Windows环境下运行起来Github上<a href="https://github.com/DayBreak-u/SOLOV2_ncnn">这个项目</a>的Demo，对于我一个电脑小白而言那背后的可都是泪呀TAT，因此有必要记录一下整个流程以方便其他人的需要~</p>
<p>  简述一下相关背景：<a href="https://github.com/Tencent/ncnn">ncnn</a>是一个前向神经网络框架，由纯C++实现所实现。而<a href="https://arxiv.org/abs/2003.10152">SOLOV2</a>是一个快速的实例分割算法，关于什么是实例分割，可参考图像处理的相关文章。此外，笔者的相关环境配置一并列举于此处，方便读者参考：</p>
<table>
<thead>
<tr>
<th style="text-align:center">环境</th>
<th style="text-align:center">版本</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Windows</td>
<td style="text-align:center">10 专业版 20H2</td>
</tr>
<tr>
<td style="text-align:center">Visual Studio 2019</td>
<td style="text-align:center">Community Edition<br>16.11.31702.278</td>
</tr>
<tr>
<td style="text-align:center">OpenCV</td>
<td style="text-align:center">3.4.5</td>
</tr>
<tr>
<td style="text-align:center">CMake</td>
<td style="text-align:center">3.21.3</td>
</tr>
<tr>
<td style="text-align:center">ncnn</td>
<td style="text-align:center"><a href="https://github.com/Tencent/ncnn/tree/2c4ae096044c816d7195476d652eb8d5aefb8379">Release 2c4ae09604</a><br>即目前的lateset release(20210720)</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="01-ncnn编译"><a class="header-anchor" href="#01-ncnn编译"></a>01 ncnn编译</h2>
<p>  理论上来讲，根据自身的需求直接使用release下官方的预编译静/动态库应该不会出现错误，然而笔者在实际配置项目时，添加了ncnn.lib这一附加依赖项后，在运行中依旧会产生Vulkan相关报错，如图所示：</p>
<p><img data-src="/img/2021-10-09-Configure-a-NCNN-Project/1.png" alt="vulkan报错"></p>
<p>  推测可能为官方打包的库中默认调用了VulkanSDK与glslang这一submoudle，因此我们需要自己来对ncnn打包了。</p>
<p>  在使用VS 2019命令行编译ncnn的过程中，也同样遇到了这样或那样的问题，不过所幸被Github上这条<a href="https://github.com/Tencent/ncnn/issues/2498">issue</a>解决了，大体上只要按照issue作者提示的操作就不会出现问题。</p>
<p>  首先在开始菜单下找到Visual Studio 2019的文件夹，打开x64 Native Tools Command Prompt这个VS 2019的命令行工具。</p>
<p><img data-src="/img/2021-10-09-Configure-a-NCNN-Project/2.png" alt="操作步骤"></p>
<p>  下载 protobuf 3.4.0 的<a href="https://github.com/google/protobuf/archive/v3.4.0.zip">源码</a>（不知道其它版本是否可行），解压，编译ncnn前需要编译protobuf。</p>
<figure class="highlight bash"><figcaption><span>Command Prompt</span></figcaption><table><tr><td class="code"><pre><span class="line">// 进入protobuf-3.4.0文件夹</span><br><span class="line"><span class="built_in">cd</span> protobuf-3.4.0</span><br><span class="line"></span><br><span class="line">// 新建build-vs2019文件夹并跳转进入</span><br><span class="line"><span class="built_in">mkdir</span> build-vs2019</span><br><span class="line"><span class="built_in">cd</span> build-vs2019</span><br><span class="line"></span><br><span class="line">// cmake -DCMAKE_BUILD_TYPE参数也可设为debug，但总之要前后一致</span><br><span class="line">cmake -G<span class="string">&quot;NMake Makefiles&quot;</span> -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=%<span class="built_in">cd</span>%/install ^</span><br><span class="line">    -Dprotobuf_BUILD_TESTS=OFF ^</span><br><span class="line">    -Dprotobuf_MSVC_STATIC_RUNTIME=OFF ../cmake</span><br><span class="line">    </span><br><span class="line">nmake</span><br><span class="line">nmake install</span><br><span class="line"></span><br><span class="line">// 返回上级文件夹，即protobuf-3.4.0文件夹之外</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>
<p>  通过git克隆ncnn的源码并编译ncnn：</p>
<div class="note warning"><p>提示：请务必注意路径问题！</p>
</div>
<figure class="highlight bash"><figcaption><span>Command Prompt</span></figcaption><table><tr><td class="code"><pre><span class="line">// 克隆远端仓库代码，放在ncnn文件夹下</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/Tencent/ncnn.git</span><br><span class="line"></span><br><span class="line">// 进入ncnn文件夹</span><br><span class="line"><span class="built_in">cd</span> ncnn</span><br><span class="line"></span><br><span class="line">// 拉取submodule</span><br><span class="line">git submodule update --init</span><br><span class="line"></span><br><span class="line">// 新建build-vs2019文件夹并跳转进入</span><br><span class="line"><span class="built_in">mkdir</span> build-vs2019</span><br><span class="line"><span class="built_in">cd</span> build-vs2019</span><br><span class="line"></span><br><span class="line">// 同上，-DCMAKE_BUILD_TYPE参数也可设为debug</span><br><span class="line">cmake -G<span class="string">&quot;NMake Makefiles&quot;</span> -DCMAKE_BUILD_TYPE=Release -DCMAKE_INSTALL_PREFIX=%<span class="built_in">cd</span>%/install ^</span><br><span class="line"></span><br><span class="line">// 更改为自己电脑上Protobuf对应文件夹所在的路径，注意：请务必改为绝对路径而不是相对路径！</span><br><span class="line">    -DProtobuf_INCLUDE_DIR=E:/Project/protobuf-3.4.0/build-vs2019/install/include ^</span><br><span class="line">    -DProtobuf_LIBRARIES=E:/Project/protobuf-3.4.0/build-vs2019/install/lib/libprotobuf.lib ^</span><br><span class="line">    -DProtobuf_PROTOC_EXECUTABLE=E:/Project/protobuf-3.4.0/build-vs2019/install/bin/protoc.exe ^</span><br><span class="line">// 更改为自己电脑上OpenCV3.4.5对应文件夹所在的路径，依然是注意绝对路径的问题</span><br><span class="line">	-DOpenCV_DIR=E:/opencv/build/x64/vc15/lib ..</span><br><span class="line">	</span><br><span class="line">nmake</span><br><span class="line">nmake install</span><br><span class="line"></span><br><span class="line">// 返回上级文件夹，即ncnn文件夹之外</span><br><span class="line"><span class="built_in">cd</span> ..</span><br><span class="line"><span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>
<p>  至此，运行此项目demo的环境构建工作就做好了，接下来就可以准备开始调试SOLOv2 ncnn的项目。</p>
<h2 id="02-项目调试"><a class="header-anchor" href="#02-项目调试"></a>02 项目调试</h2>
<p>  与上一步相同，首先需要使用获得一份源码：</p>
<figure class="highlight bash"><figcaption><span>Command Prompt</span></figcaption><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/DayBreak-u/SOLOV2_ncnn.git</span><br></pre></td></tr></table></figure>
<p>  根据<a href="https://github.com/DayBreak-u/SOLOV2_ncnn">项目主页</a><a href="http://xn--README-ow6o.md">的README.md</a>，执行前三行代码：</p>
<figure class="highlight bash"><figcaption><span>Command Prompt</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ncnn</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> build</span><br><span class="line"><span class="built_in">cd</span> build </span><br><span class="line">cmake ..</span><br></pre></td></tr></table></figure>
<p>  如果存在报错信息如<code>CMake Error at CMakeLists.txt:xx (find_package):Could not find module FindOpenCV.cmake or a configuration file for package OpenCV.</code>则是没有寻找到OpenCV的CMake文件，可在文件中添加一行<code>set(OpenCV_DIR E:/opencv/build/x64/vc15/lib)</code> （请替换为自己OpenCV的路径）或者是配置OpenCV_DIR这一环境变量即可。提示<code>-- Configuring done</code>、<code>-- Generating done</code>时即意味着项目解决方案的成功生成。</p>
<p>  下载模型权重：</p>
<blockquote>
<p>链接: <a href="https://pan.baidu.com/s/1W1AiKdI4JJq2LW50uGOVng">https://pan.baidu.com/s/1W1AiKdI4JJq2LW50uGOVng</a> 密码: phh8</p>
</blockquote>
<p>  在Windows环境下，由于没有Linux下的GNU Make，所以我们直接用VS来编译代码：</p>
<h3 id="VS配置ncnn和opencv环境"><a class="header-anchor" href="#VS配置ncnn和opencv环境"></a>VS配置ncnn和opencv环境</h3>
<p>  点击<code>项目</code>-&gt;<code>属性</code>-&gt;<code>VC++目录</code>，在Release配置、x64平台下，根据自己目录的实际情况添加以下路径至<code>包含目录</code>：</p>
<div class="note warning"><p>注意：如果前文中您将protobuf、ncnn的源码编译为debug版本，则此处也要将其改为debug配置。</p>
</div>
<p>  <code>E:\opencv\build\include</code><br>
  <code>E:\opencv\build\include\opencv</code><br>
  <code>E:\opencv\build\include\opencv2</code><br>
  <code>E:\Project\ncnn\build-vs2019\install\include</code><br>
  <code>E:\Project\ncnn\build-vs2019\install\include\ncnn</code></p>
<p>  同样，在<code>库目录</code> 中根据自身情况添加以下路径：</p>
<p>  <code>E:\opencv\build\x64\vc15\lib</code><br>
  <code>E:\Project\ncnn\build-vs2019\install\lib</code></p>
<p>  在<code>链接器</code>-&gt;<code>输入</code>中加入<code>ncnn.lib</code>、<code>opencv_world345.lib</code>这两个<code>附加依赖项</code>就可以进行下一步操作了。</p>
<h3 id="修改代码"><a class="header-anchor" href="#修改代码"></a>修改代码</h3>
<p>  为方便运行demo查看效果，我对其进行了一定修改，以solov2.cpp为例（<del>才不是我没有测试过solov2_fast.cpp的原因呢</del>，哼o(~ヘ~o#)）：</p>
<p>  根据前文下载的模型权重存储路径修改权重读取位置：</p>
<p><img data-src="/img/2021-10-09-Configure-a-NCNN-Project/3.png" alt="修改代码"></p>
<p>  注释并重写main函数：</p>
<figure class="highlight c++"><figcaption><span>solov2.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>* imagepath = <span class="string">&quot;E:/Project/SOLOV2_ncnn/imgs/horses.jpg&quot;</span>;</span><br><span class="line"></span><br><span class="line">    cv::Mat m = cv::<span class="built_in">imread</span>(imagepath, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (m.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(stderr, <span class="string">&quot;cv::imread %s failed\n&quot;</span>, imagepath);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::vector &lt;Object&gt; objects;</span><br><span class="line">    <span class="built_in">detect_solov2</span>(m, objects);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">draw_objects</span>(m, objects);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  程序生成的结果result.png默认放在项目build文件夹下，如果您想要直观地看见程序运行的效果，可以将main函数上方原作者注释掉的两行代码取消注释：<br>
  <code>//    cv::imshow(&quot;image&quot;, image);</code><br>
  <code>//    cv::waitKey(0);</code></p>
<h3 id="运行代码"><a class="header-anchor" href="#运行代码"></a>运行代码</h3>
<p>  做完上述操作后，在<code>解决方案资源管理器</code>中右键我们修改代码后的<code>solov2</code>并设为启动项目：</p>
<p><img data-src="/img/2021-10-09-Configure-a-NCNN-Project/4.png" alt="修改代码"></p>
<p>  然后点击<code>本地Windows调试器</code>编译并运行程序。一般情况下，我们的<code>solov2.exe</code>就成功生成了。如果控制台打开提示找不到 <code>opencv_world345.dll</code>，就在<code>../opencv/build/x64/vc15/bin</code>文件夹下拷贝一份放在<code>../SOLOv2_ncnn/build/Release</code>下，该文件夹也是<code>solov2.exe</code>所在的地方。</p>
<p>  运行窗口如图：</p>
<p><img data-src="/img/2021-10-09-Configure-a-NCNN-Project/5.png" alt="运行窗口"></p>
<p>  运行效果如图：</p>
<p><img data-src="/img/2021-10-09-Configure-a-NCNN-Project/horses.jpg" alt="运行效果1" title="读取到的图片"></p>
<p><img data-src="/img/2021-10-09-Configure-a-NCNN-Project/result.png" alt="运行效果2" title="实例分割的结果"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>机器学习</tag>
        <tag>SOLOv2</tag>
      </tags>
  </entry>
  <entry>
    <title>用VS 2019打包dll文件</title>
    <url>/2021/09/29/How-to-Package-a-dll/</url>
    <content><![CDATA[<p>  最近在看学长接手的<a href="https://sao-kirito.top/2021/09/15/shape_based_matching/">形状匹配(shape based matching)C++工程</a>，虽然看懂的不多，但是被要求将部分代码打包封装成dll，暴露简洁的接口供调用者使用。<br>
  在流程上，我参考了另一位师兄给的<a href="https://blog.csdn.net/weixin_42435145/article/details/104199125">链接</a>里的步骤。现结合具体工程记述如下：<span id="more"></span></p>
<h2 id="创建dll项目"><a class="header-anchor" href="#创建dll项目"></a>创建dll项目</h2>
<p>  打开Visual Studio 2019，在界面中选择<code>创建新项目(<u>N</u>)</code>。</p>
<p><img data-src="/img/2021-09-29-How-to-Package-a-dll/01.png" alt="创建新项目"></p>
<p>  随后选择<code>动态链接库</code>项目，按照步骤依次将项目名称、位置以及解决方案名称设置好。创建完成后结构如图所示：</p>
<p><img data-src="/img/2021-09-29-How-to-Package-a-dll/02.png" alt="创建完成"></p>
<h2 id="引入调用的文件、配置项目所需的OpenCV库文件"><a class="header-anchor" href="#引入调用的文件、配置项目所需的OpenCV库文件"></a>引入调用的文件、配置项目所需的OpenCV库文件</h2>
<p>  将原项目中所有<code>.h</code>的头文件复制到该解决方案所在的文件夹中，并右键单击解决方案的<code>头文件</code>-&gt;<code>添加</code>-&gt;<code>现有项</code>，将这些头文件添加进解决方案中，所有被调用到的<code>.cpp</code>也进行相同的操作。完成之后的结果如下：</p>
<p><img data-src="/img/2021-09-29-How-to-Package-a-dll/03.png" alt="引入头文件与源文件"></p>
<p>  由于此项目涉及图像处理最常用的OpenCV库，打包dll也需要进行相应的环境配置。点击VS菜单栏的<code>视图(V)</code>-&gt;<code>属性管理器</code>，右键单击本项目，选择<code>添加新项目属性表</code>，添加后双击该属性表进行编辑。在<code>VC++目录</code>的包含目录中配置路径如下：</p>
<div align = "center"><code>..\OpenCV\build\include</code>
</div>
<div align = "center"><code>..\OpenCV\build\include\opencv</code>
</div>
<div align = "center"><code>..\OpenCV\build\include\opencv2</code>
</div>
<p>  在库目录中配置路径为：<code>..\OpenCV\build\x64\vc15\lib </code></p>
<p>  在<code>链接器</code>-&gt;<code>输入</code>的附加依赖项中添加<code>opencv_world346d.lib</code>（在Release版本下则是<code>opencv_world346.lib</code>）。</p>
<p>  这样，我们所有的先期准备工作就做好了。</p>
<h2 id="编写dll函数"><a class="header-anchor" href="#编写dll函数"></a>编写dll函数</h2>
<p>  在<code>pch.h</code>文件中，需要写上准备调用的函数声明，由于这些函数也要调用各自的头文件，因此可以把它们集中放在这个文件里，而在源文件中只需要包含<code>pch.h</code>即可。</p>
<figure class="highlight c++"><figcaption><span>pch.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加要在此处预编译的标头</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;framework.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;line2Dup.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">point</span>&#123;</span><br><span class="line">	<span class="type">float</span> x;</span><br><span class="line">	<span class="type">float</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">recognizedObjectLocation</span></span><br><span class="line">&#123;</span><br><span class="line">	point topleft;</span><br><span class="line">	point center;</span><br><span class="line">	<span class="type">float</span> angle;</span><br><span class="line">	<span class="type">float</span> scale;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> _declspec(dllexport) <span class="function"><span class="type">void</span> <span class="title">train</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">				string imgLocation, </span></span></span><br><span class="line"><span class="params"><span class="function">				string saveTemplateDIR, </span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">int</span> num_feature, Rect roi, <span class="type">int</span> padding, </span></span></span><br><span class="line"><span class="params"><span class="function">				string class_id)</span></span>;</span><br><span class="line">_declspec(dllexport) <span class="function">vector&lt;recognizedObjectLocation&gt; <span class="title">test</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">				string testImgLocation, </span></span></span><br><span class="line"><span class="params"><span class="function">				string loadTemplateDir, <span class="type">int</span> num_feature, </span></span></span><br><span class="line"><span class="params"><span class="function">				Rect train_roi, <span class="type">int</span> train_padding, string class_id, </span></span></span><br><span class="line"><span class="params"><span class="function">				<span class="type">int</span> score_thershold, <span class="type">int</span> nms_thershold)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">//PCH_H</span></span></span><br></pre></td></tr></table></figure>
<p>  此处工作基本上是按部就班地参考网上教程而来的，在声明函数前，则需要添加上<code>extern &quot;C&quot; _declspec(dllexport)</code>这样的语句，而函数的返回值为C++类型时，譬如我这里自定义的recognizedObjectLocation类型的vector容器，就可以删去<code>extern &quot;C&quot;</code>的语句，否则会产生相应的报错，此处我也不甚了解，只是找到了网上给的解决方法而已。</p>
<p>  在<code>pch.cpp</code>中，我们需要对自己编写的函数进行实现。需要注意的是：即使函数没有实现，在编译生成时，VS并不会报错而是正常生成对应的<code>.lib</code>与<code>.dll</code>文件，直到调用dll的代码进行编译时才会产生链接过程中的错误<code>LNK 2001 无法解析的外部符号...</code>。（小插曲：这段问题是我自己在编写dll过程中所遇到的问题，由于在函数声明和编写函数时，我所写的函数设置的参数数量不一样，被编译器视作不同的函数，所以链接时才找不到函数定义。）</p>
<details class="note info no-icon"><summary><p>函数实现代码pch.cpp</p>
</summary>
<figure class="highlight c++"><figcaption><span>pch.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// pch.cpp: 与预编译标头对应的源文件</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="keyword">namespace</span>  cv_dnn &#123;</span><br><span class="line">	<span class="keyword">namespace</span></span><br><span class="line">	&#123;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">		<span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">bool</span> <span class="title">SortScorePairDescend</span><span class="params">(<span class="type">const</span> std::pair&lt;<span class="type">float</span>, T&gt;&amp; pair1,</span></span></span><br><span class="line"><span class="params"><span class="function">			<span class="type">const</span> std::pair&lt;<span class="type">float</span>, T&gt;&amp; pair2)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> pair1.first &gt; pair2.first;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	&#125; <span class="comment">// namespace</span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">GetMaxScoreIndex</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; scores, <span class="type">const</span> <span class="type">float</span> threshold, </span></span></span><br><span class="line"><span class="params"><span class="function">                                 <span class="type">const</span> <span class="type">int</span> top_k,std::vector&lt;std::pair&lt;<span class="type">float</span>, <span class="type">int</span>&gt; &gt;&amp; score_index_vec)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; scores.<span class="built_in">size</span>(); ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (scores[i] &gt; threshold)</span><br><span class="line">			&#123;</span><br><span class="line">				score_index_vec.<span class="built_in">push_back</span>(std::<span class="built_in">make_pair</span>(scores[i], i));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		std::<span class="built_in">stable_sort</span>(score_index_vec.<span class="built_in">begin</span>(), score_index_vec.<span class="built_in">end</span>(),</span><br><span class="line">			SortScorePairDescend&lt;<span class="type">int</span>&gt;);</span><br><span class="line">		<span class="keyword">if</span> (top_k &gt; <span class="number">0</span> &amp;&amp; top_k &lt; (<span class="type">int</span>)score_index_vec.<span class="built_in">size</span>())</span><br><span class="line">		&#123;</span><br><span class="line">			score_index_vec.<span class="built_in">resize</span>(top_k);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> BoxType&gt;</span><br><span class="line">	<span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">NMSFast_</span><span class="params">(<span class="type">const</span> std::vector&lt;BoxType&gt;&amp; bboxes,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; scores, <span class="type">const</span> <span class="type">float</span> score_threshold,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> <span class="type">float</span> nms_threshold, <span class="type">const</span> <span class="type">float</span> eta, <span class="type">const</span> <span class="type">int</span> top_k,</span></span></span><br><span class="line"><span class="params"><span class="function">		std::vector&lt;<span class="type">int</span>&gt;&amp; indices, <span class="type">float</span> (*computeOverlap)(<span class="type">const</span> BoxType&amp;, <span class="type">const</span> BoxType&amp;))</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">CV_Assert</span>(bboxes.<span class="built_in">size</span>() == scores.<span class="built_in">size</span>());</span><br><span class="line">		std::vector&lt;std::pair&lt;<span class="type">float</span>, <span class="type">int</span>&gt; &gt; score_index_vec;</span><br><span class="line">		<span class="built_in">GetMaxScoreIndex</span>(scores, score_threshold, top_k, score_index_vec);</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do nms.</span></span><br><span class="line">		<span class="type">float</span> adaptive_threshold = nms_threshold;</span><br><span class="line">		indices.<span class="built_in">clear</span>();</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; score_index_vec.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">			<span class="type">const</span> <span class="type">int</span> idx = score_index_vec[i].second;</span><br><span class="line">			<span class="type">bool</span> keep = <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">0</span>; k &lt; (<span class="type">int</span>)indices.<span class="built_in">size</span>() &amp;&amp; keep; ++k) &#123;</span><br><span class="line">				<span class="type">const</span> <span class="type">int</span> kept_idx = indices[k];</span><br><span class="line">				<span class="type">float</span> overlap = <span class="built_in">computeOverlap</span>(bboxes[idx], bboxes[kept_idx]);</span><br><span class="line">				keep = overlap &lt;= adaptive_threshold;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (keep)</span><br><span class="line">				indices.<span class="built_in">push_back</span>(idx);</span><br><span class="line">			<span class="keyword">if</span> (keep &amp;&amp; eta &lt; <span class="number">1</span> &amp;&amp; adaptive_threshold &gt; <span class="number">0.5</span>) &#123;</span><br><span class="line">				adaptive_threshold *= eta;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">// copied from opencv 3.4, not exist in 3.0</span></span><br><span class="line">	<span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> _Tp&gt; <span class="type">static</span> <span class="keyword">inline</span></span></span><br><span class="line"><span class="function">		<span class="type">double</span> <span class="title">jaccardDistance__</span><span class="params">(<span class="type">const</span> Rect_&lt;_Tp&gt;&amp; a, <span class="type">const</span> Rect_&lt;_Tp&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">		_Tp Aa = a.<span class="built_in">area</span>();</span><br><span class="line">		_Tp Ab = b.<span class="built_in">area</span>();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ((Aa + Ab) &lt;= std::numeric_limits&lt;_Tp&gt;::<span class="built_in">epsilon</span>()) &#123;</span><br><span class="line">			<span class="comment">// jaccard_index = 1 -&gt; distance = 0</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="type">double</span> Aab = (a &amp; b).<span class="built_in">area</span>();</span><br><span class="line">		<span class="comment">// distance = 1 - jaccard_index</span></span><br><span class="line">		<span class="keyword">return</span> <span class="number">1.0</span> - Aab / (Aa + Ab - Aab);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="function"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">float</span> <span class="title">rectOverlap</span><span class="params">(<span class="type">const</span> T&amp; a, <span class="type">const</span> T&amp; b)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1.f</span> - <span class="built_in">static_cast</span>&lt;<span class="type">float</span>&gt;(<span class="built_in">jaccardDistance__</span>(a, b));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">NMSBoxes</span><span class="params">(<span class="type">const</span> std::vector&lt;Rect&gt;&amp; bboxes, <span class="type">const</span> std::vector&lt;<span class="type">float</span>&gt;&amp; scores,</span></span></span><br><span class="line"><span class="params"><span class="function">		<span class="type">const</span> <span class="type">float</span> score_threshold, <span class="type">const</span> <span class="type">float</span> nms_threshold,</span></span></span><br><span class="line"><span class="params"><span class="function">		std::vector&lt;<span class="type">int</span>&gt;&amp; indices, <span class="type">const</span> <span class="type">float</span> eta = <span class="number">1</span>, <span class="type">const</span> <span class="type">int</span> top_k = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="built_in">NMSFast_</span>(bboxes, scores, score_threshold, nms_threshold, eta, top_k, indices, rectOverlap);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当使用预编译的头时，需要使用此源文件，编译才能成功。</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">train</span><span class="params">(string imgLocation, string saveTemplateDir, <span class="type">int</span> num_feature, Rect roi, <span class="type">int</span> padding, string class_id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">line2Dup::Detector <span class="title">detector</span><span class="params">(num_feature, &#123; <span class="number">4</span>, <span class="number">8</span> &#125;)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// read the img</span></span><br><span class="line">	Mat img = <span class="built_in">imread</span>(imgLocation);</span><br><span class="line">	<span class="built_in">assert</span>(!img.<span class="built_in">empty</span>() &amp;&amp; <span class="string">&quot;check your img path&quot;</span>);</span><br><span class="line">	<span class="comment">// cut the object out of img, location depends on &quot;roi&quot;</span></span><br><span class="line">	img = <span class="built_in">img</span>(roi).<span class="built_in">clone</span>();</span><br><span class="line"></span><br><span class="line">	Mat mask = <span class="built_in">Mat</span>(img.<span class="built_in">size</span>(), CV_8UC1, &#123; <span class="number">255</span> &#125;);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// padding to avoid rotating out</span></span><br><span class="line">	cv::Mat padded_img = cv::<span class="built_in">Mat</span>(img.rows + <span class="number">2</span> * padding, img.cols + <span class="number">2</span> * padding, img.<span class="built_in">type</span>(), cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line">	img.<span class="built_in">copyTo</span>(<span class="built_in">padded_img</span>(<span class="built_in">Rect</span>(padding, padding, img.cols, img.rows)));</span><br><span class="line">	cv::Mat padded_mask = cv::<span class="built_in">Mat</span>(mask.rows + <span class="number">2</span> * padding, mask.cols + <span class="number">2</span> * padding, mask.<span class="built_in">type</span>(), cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line">	mask.<span class="built_in">copyTo</span>(<span class="built_in">padded_mask</span>(<span class="built_in">Rect</span>(padding, padding, img.cols, img.rows)));</span><br><span class="line"></span><br><span class="line">	<span class="function">shape_based_matching::shapeInfo_producer <span class="title">shapes</span><span class="params">(padded_img, padded_mask)</span></span>;</span><br><span class="line">	shapes.angle_range = &#123; <span class="number">0</span>, <span class="number">360</span> &#125;;    <span class="comment">// 模板库角度范围</span></span><br><span class="line">	shapes.angle_step = <span class="number">1</span>;  <span class="comment">// 模板库角度步长</span></span><br><span class="line">	<span class="comment">//shapes.scale_range = &#123; 0.9f, 1.1f &#125;;  // 模板库尺度范围</span></span><br><span class="line">	<span class="comment">//shapes.scale_step = 0.05f;     模板库尺度步长</span></span><br><span class="line">	shapes.scale_range = &#123; <span class="number">1.0f</span> &#125;;</span><br><span class="line">	shapes.<span class="built_in">produce_infos</span>();</span><br><span class="line">	std::vector&lt;shape_based_matching::shapeInfo_producer::Info&gt; infos_have_templ;</span><br><span class="line"></span><br><span class="line">	<span class="type">bool</span> is_first = <span class="literal">true</span>;</span><br><span class="line">	<span class="comment">// for other scales you want to re-extract points: </span></span><br><span class="line">	<span class="comment">// set shapes.scale_range then produce_infos; set is_first = false;</span></span><br><span class="line">	<span class="type">int</span> first_id = <span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> first_angle = <span class="number">0</span>;</span><br><span class="line">	<span class="type">float</span> first_scale = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span>&amp; info : shapes.infos) &#123;</span><br><span class="line">		Mat to_show = shapes.<span class="built_in">src_of</span>(info);</span><br><span class="line">		<span class="type">int</span> templ_id = detector.<span class="built_in">addTemplate</span>(shapes.<span class="built_in">src_of</span>(info), class_id, shapes.<span class="built_in">mask_of</span>(info),</span><br><span class="line">			<span class="built_in">int</span>(num_feature * info.scale));</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (templ_id != <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">auto</span> templ = detector.<span class="built_in">getTemplates</span>(class_id, templ_id);</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; templ[<span class="number">0</span>].features.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">				<span class="keyword">auto</span> feat = templ[<span class="number">0</span>].features[i];</span><br><span class="line">				cv::<span class="built_in">circle</span>(to_show, &#123; feat.x + templ[<span class="number">0</span>].tl_x, feat.y + templ[<span class="number">0</span>].tl_y &#125;, <span class="number">3</span>, &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span> &#125;, <span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			infos_have_templ.<span class="built_in">push_back</span>(info);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">fabs</span>(info.scale - first_scale) &gt; <span class="number">0.002f</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			is_first = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// .../class_id_templ.yaml</span></span><br><span class="line">		detector.<span class="built_in">writeClasses</span>(saveTemplateDir + class_id + <span class="string">&quot;_templ.yaml&quot;</span>);  <span class="comment">// 模板库</span></span><br><span class="line">		shapes.<span class="built_in">save_infos</span>(infos_have_templ, saveTemplateDir + class_id + <span class="string">&quot;_info.yaml&quot;</span>);   <span class="comment">// 模板信息</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">vector&lt;recognizedObjectLocation&gt; <span class="title">test</span><span class="params">(string testImgLocation, string loadTemplateDir, <span class="type">int</span> num_feature, </span></span></span><br><span class="line"><span class="params"><span class="function">                                      Rect train_roi, <span class="type">int</span> train_padding, string class_id, </span></span></span><br><span class="line"><span class="params"><span class="function">                                      <span class="type">int</span> score_thershold = <span class="number">90</span>, <span class="type">int</span> nms_thershold = <span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	vector&lt;recognizedObjectLocation&gt; ObjLocations;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	std::vector&lt;std::string&gt; ids;</span><br><span class="line">	ids.<span class="built_in">push_back</span>(class_id);</span><br><span class="line">	<span class="function">line2Dup::Detector <span class="title">detector</span><span class="params">(num_feature, &#123; <span class="number">4</span>, <span class="number">8</span> &#125;)</span></span>;</span><br><span class="line">	detector.<span class="built_in">readClasses</span>(ids, loadTemplateDir + class_id + <span class="string">&quot;_templ.yaml&quot;</span>);</span><br><span class="line">	<span class="keyword">auto</span> infos = shape_based_matching::shapeInfo_producer::<span class="built_in">load_infos</span>(loadTemplateDir + class_id + <span class="string">&quot;_info.yaml&quot;</span>);</span><br><span class="line"></span><br><span class="line">	Mat test_img = <span class="built_in">imread</span>(testImgLocation);</span><br><span class="line">	<span class="built_in">assert</span>(!test_img.<span class="built_in">empty</span>() &amp;&amp; <span class="string">&quot;check your img path&quot;</span>);</span><br><span class="line">	<span class="comment">// padding to avoid rotating out</span></span><br><span class="line">	<span class="type">int</span> padding = <span class="number">0</span>;</span><br><span class="line">	cv::Mat padded_img = cv::<span class="built_in">Mat</span>(test_img.rows + <span class="number">2</span> * padding,</span><br><span class="line">		test_img.cols + <span class="number">2</span> * padding, test_img.<span class="built_in">type</span>(), cv::Scalar::<span class="built_in">all</span>(<span class="number">0</span>));</span><br><span class="line">	test_img.<span class="built_in">copyTo</span>(<span class="built_in">padded_img</span>(<span class="built_in">Rect</span>(padding, padding, test_img.cols, test_img.rows)));</span><br><span class="line">	<span class="type">int</span> stride = <span class="number">32</span>;</span><br><span class="line">	<span class="type">int</span> n = padded_img.rows / stride;</span><br><span class="line">	<span class="type">int</span> m = padded_img.cols / stride;</span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>, stride * m, stride * n)</span></span>;</span><br><span class="line">	Mat img = <span class="built_in">padded_img</span>(roi).<span class="built_in">clone</span>();</span><br><span class="line">	<span class="built_in">assert</span>(img.<span class="built_in">isContinuous</span>());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> matches = detector.<span class="built_in">match</span>(img, score_thershold, ids);</span><br><span class="line"></span><br><span class="line">	vector&lt;Rect&gt; boxes;</span><br><span class="line">	vector&lt;<span class="type">float</span>&gt; scores;</span><br><span class="line">	vector&lt;<span class="type">int</span>&gt; idxs;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> match : matches) &#123;</span><br><span class="line">		Rect box;</span><br><span class="line">		box.x = match.x;</span><br><span class="line">		box.y = match.y;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> templ = detector.<span class="built_in">getTemplates</span>(class_id, match.template_id);</span><br><span class="line"></span><br><span class="line">		box.width = templ[<span class="number">0</span>].width;</span><br><span class="line">		box.height = templ[<span class="number">0</span>].height;</span><br><span class="line">		boxes.<span class="built_in">push_back</span>(box);</span><br><span class="line">		scores.<span class="built_in">push_back</span>(match.similarity);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	cv_dnn::<span class="built_in">NMSBoxes</span>(boxes, scores, score_thershold, nms_thershold, idxs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> idx : idxs)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">auto</span> match = matches[idx];</span><br><span class="line">		<span class="keyword">auto</span> templ = detector.<span class="built_in">getTemplates</span>(class_id,  <span class="comment">// 读取训练好的模板类</span></span><br><span class="line">			match.template_id);</span><br><span class="line"></span><br><span class="line">		recognizedObjectLocation obj;</span><br><span class="line"></span><br><span class="line">		obj.topleft.x = match.x;</span><br><span class="line">		obj.topleft.y = match.y;</span><br><span class="line"><span class="comment">// Update 21/10/5 今天才发现train_roi这里写错了，应该是train_roi.weight 和 train_roi.height</span></span><br><span class="line">		<span class="type">float</span> train_img_half_width = train_roi.x / <span class="number">2.0f</span> + train_padding;</span><br><span class="line">		<span class="type">float</span> train_img_half_height = train_roi.y / <span class="number">2.0f</span> + train_padding;</span><br><span class="line">		obj.center.x = match.x - templ[<span class="number">0</span>].tl_x + train_img_half_width;</span><br><span class="line">		obj.center.y = match.y - templ[<span class="number">0</span>].tl_y + train_img_half_height;</span><br><span class="line"></span><br><span class="line">		obj.angle = <span class="number">360</span> - infos[match.template_id].angle;</span><br><span class="line">		obj.scale = infos[match.template_id].scale;</span><br><span class="line"></span><br><span class="line">		ObjLocations.<span class="built_in">push_back</span>(obj);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ObjLocations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</details>
<p>  另外，我把line2Dup.cpp中一些输出语句注释掉了，屏蔽掉控制台的输出。而TerryJoe学长解释了代码中各个坐标系下变换中公式的由来，现一并粘贴于此（无关信息已马赛克处理。）<br>
<img data-src="/img/2021-09-29-How-to-Package-a-dll/04.png" alt="说明"></p>
<h2 id="生成dll文件"><a class="header-anchor" href="#生成dll文件"></a>生成dll文件</h2>
<p>  点击<code>本地Windows调试器</code>，若提示错误：<code>在查找预编译头时遇到意外的文件结尾。是否忘记了向源中添加“#include”pch.h”</code>，则点击菜单栏中的<code>项目</code>-&gt;<code>项目名属性</code>-&gt;<code>C/C++</code>-&gt;<code>预编译头</code>，将右侧的预编译头由<code>使用(/Yu)</code>调换到<code>不使用预编译头</code>，然后点击<code>应用</code>-&gt;<code>确定</code>。<br>
  再次运行时即能正确运行，若输出显示<code>========== 生成: 成功 1 个，失败 0 个，最新 0 个，跳过 0 个 ==========</code>即为成功，此时会弹出错误框，显示<code>无法启动dll，dll不是有效的Win32应用程序。</code>我们关闭即可，dll必须由其他程序调用。此时我们在项目目录中的Debug或Release目录下即找到生成的<code>.dll</code>文件。</p>
<h2 id="调用dll文件"><a class="header-anchor" href="#调用dll文件"></a>调用dll文件</h2>
<p>  现在创建一个空的工程项目，创建主程序调用上述函数。</p>
<figure class="highlight c++"><figcaption><span>test.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	string imgLocation = <span class="string">&quot;D:/Work/202109/shape_match_fusion/test/case3/train.jpg&quot;</span>;</span><br><span class="line">	string saveTemplateDir = <span class="string">&quot;D:/Work/202109/shape_match_fusion/test/case3/temp/&quot;</span>;</span><br><span class="line">	<span class="type">int</span> num_feature = <span class="number">16</span>;</span><br><span class="line">	<span class="function">Rect <span class="title">roi</span><span class="params">(<span class="number">90</span>, <span class="number">35</span>, <span class="number">65</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line">	<span class="type">int</span> padding = <span class="number">25</span>;</span><br><span class="line">	string class_id = <span class="string">&quot;gongjian&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">train</span>(imgLocation, saveTemplateDir, num_feature, roi, padding, class_id);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;已生成模板库文件&quot;</span> &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	string testImgLocation = <span class="string">&quot;D:/Work/202109/shape_match_fusion/test/case3/ori.jpg&quot;</span>;</span><br><span class="line">	vector&lt;recognizedObjectLocation&gt; ObjLocations;</span><br><span class="line">	ObjLocations = <span class="built_in">test</span>(testImgLocation, saveTemplateDir, num_feature, roi, padding, class_id);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : ObjLocations)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;物体左上角点横坐标：&quot;</span> &lt;&lt; i.topleft.x &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;物体左上角点纵坐标：&quot;</span> &lt;&lt; i.topleft.y &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;物体中心点横坐标：&quot;</span> &lt;&lt; i.center.x &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;物体中心点纵坐标：&quot;</span> &lt;&lt; i.center.y &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;物体顺时针旋转角度：&quot;</span> &lt;&lt; i.angle &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;物体尺度大小变化：&quot;</span> &lt;&lt; i.scale &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;-----------------------------&quot;</span> &lt;&lt; endl;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  将dll项目中的各个头文件添加进测试项目之中。将第四步中生成的<code>.dll</code>、<code>.lib</code>文件粘贴于调用函数程序同一文件夹下，如图所示：</p>
<p><img data-src="/img/2021-09-29-How-to-Package-a-dll/05.png" alt="项目结构"></p>
<p>  然后按照第二步里的方法，添加OpenCV库，并在<code>链接器</code>-&gt;<code>输入</code>的附加依赖项中额外添加之前生成的<code>.lib</code>文件。</p>
<p>  最后运行程序即可：</p>
<p><img data-src="/img/2021-09-29-How-to-Package-a-dll/06.png" alt="项目结构"></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
      </tags>
  </entry>
  <entry>
    <title>使用Python读写XML文件</title>
    <url>/2021/10/12/Use-Python-to-Read-and-Write-XML-files/</url>
    <content><![CDATA[<p>  因学长所用的<a href="https://sao-kirito.top/2021/10/09/yolov5-dota-obb/">某个针对yolov5的修改版训练网络</a>针对<strong>宽高不等的图片无法作为数据正常送入网络进行训练</strong>，而先期使用labelimg2标注工具所截取的图片往往都不是正方形，所以我要对之前处理的图片进行padding处理使之成为正方形。同时padding操作改变了图片的坐标系位置以及图片宽高属性，因此要对标签(XML文件)进行更新操作，而这涉及到对XML文件的读写，在网上查询相关资料后，我成功实现了预期目标。</p>
<span id="more"></span>
<h2 id="01-XML文件的结构"><a class="header-anchor" href="#01-XML文件的结构"></a>01 XML文件的结构</h2>
<p>  XML文件作为一种被设计为传输、存储结构化数据信息的文件结构，其语法简洁清晰，没有其它的预定义标签，以一个简单的XML文档为例：</p>
<figure class="highlight xml"><figcaption><span>testfile.xml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">addressbook</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">gender</span> = <span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Jack<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">id</span>&gt;</span>01<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tel</span>&gt;</span>10000<span class="tag">&lt;/<span class="name">tel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">province</span>&gt;</span>Jiangsu<span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>Nanking<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">gender</span> = <span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">name</span>&gt;</span>Maria<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">id</span>&gt;</span>02<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tel</span>&gt;</span>10001<span class="tag">&lt;/<span class="name">tel</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">address</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">province</span>&gt;</span>Anhui<span class="tag">&lt;/<span class="name">province</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">city</span>&gt;</span>Hefei<span class="tag">&lt;/<span class="name">city</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">address</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">person</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">addressbook</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>  其中第一行<strong>必须</strong>是<strong>XML声明</strong>，在文件的前面不能有其它元素或者注释，它定义 XML 的版本和所使用的编码方式，第二行开始是一个<strong>根元素</strong>，在这个例子中，根元素是<code>&lt;addressbook&gt;</code>...<code>&lt;/addressbook&gt;</code>。接下来的<code>&lt;person&gt;</code>标签是根元素的<strong>子元素</strong>，而对应的，根元素为所有子元素的父元素。所有元素都有对应的子元素，都可以拥有文本内容和<strong>属性</strong>，例如<code>&lt;person&gt;</code>标签的属性名<code>gender</code>，其对应的属性值由双引号<code>&quot;</code>括起来。</p>
<p>  其它需要注意的内容诸如标签名大小写敏感、注释格式等可以参考其它网络文章：<br>
  <a href="https://www.w3school.com.cn/xml/xml_tree.asp">XML 树结构 (w3school.com.cn)</a><br>
  <a href="https://www.cnblogs.com/klb561/p/9196515.html">XML文件结构和基本语法 - konglingbin - 博客园 (cnblogs.com)</a><br>
  <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017784095418144">XML - 廖雪峰的官方网站 (liaoxuefeng.com)</a></p>
<h2 id="02-DOM解析XML文件"><a class="header-anchor" href="#02-DOM解析XML文件"></a>02 DOM解析XML文件</h2>
<blockquote>
<p>文件对象模型（Document Object Model，简称DOM），是W3C组织推荐的处理可扩展置标语言的标准编程接口。一个 DOM 的解析器在解析一个XML文档时，一次性读取整个文档，把文档中所有元素保存在内存中的一个树结构里，之后你可以利用DOM 提供的不同的函数来读取或修改文档的内容和结构，也可以把修改过的内容写入xml文件。python中用xml.dom.minidom来解析xml文件。</p>
</blockquote>
<p>  参考了几篇网络教程，废话不多说，直接上手开干！</p>
<h3 id="读取"><a class="header-anchor" href="#读取"></a>读取</h3>
<div>
	<div class="left">
<figure class="highlight python"><figcaption><span>Python代码</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.dom.minidom <span class="keyword">as</span> minidom</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">filepath = os.path.abspath(<span class="string">&quot;testfile.xml&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;读取文件路径:&quot;</span>, filepath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立DOM对象</span></span><br><span class="line">objectTree = minidom.parse(filepath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取根元素(addressbook)</span></span><br><span class="line">rootElement = objectTree.documentElement</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;变量类型:&quot;</span>, <span class="built_in">type</span>(rootElement))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;根元素名:&quot;</span>, rootElement.nodeName)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以名字获得子元素(person)</span></span><br><span class="line">persons = rootElement.getElementsByTagName(<span class="string">&quot;person&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取到的子元素以节点列表方式存储</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;变量类型:&quot;</span>, <span class="built_in">type</span>(persons))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 利用索引号，可获取指定的某一个元素</span></span><br><span class="line">Jack = persons[<span class="number">0</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;节点列表中某一个元素的类型:&quot;</span>, <span class="built_in">type</span>(Jack))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 元素属性的读取</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Jack性别:&quot;</span>, Jack.getAttribute(<span class="string">&quot;gender&quot;</span>))</span><br><span class="line"><span class="comment"># 通过节点获取属性</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Jack性别:&quot;</span>, Jack.getAttributeNode(<span class="string">&quot;gender&quot;</span>).nodeValue)</span><br><span class="line"><span class="comment"># 文本内容的读取</span></span><br><span class="line">tel = Jack.getElementsByTagName(<span class="string">&quot;tel&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;tel:&quot;</span>, tel[<span class="number">0</span>].childNodes[<span class="number">0</span>].data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 按照索引号获取元素</span></span><br><span class="line"><span class="comment"># childNodes[0]存储的内容为当前元素的文本节点</span></span><br><span class="line"><span class="comment"># 文本节点也被DOM视作某个元素的子元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Jack.childNodes[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Jack.childNodes[<span class="number">1</span>]))</span><br><span class="line"><span class="built_in">print</span>(Jack.childNodes[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有Text类型才具有.data方法，获得文本内容</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(Jack.childNodes[<span class="number">1</span>].childNodes[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(Jack.childNodes[<span class="number">1</span>].childNodes[<span class="number">0</span>].data)</span><br><span class="line"><span class="comment"># 或者通过.nodeValue方法获得元素的文本，两者应该等价</span></span><br><span class="line"><span class="built_in">print</span>(Jack.childNodes[<span class="number">1</span>].childNodes[<span class="number">0</span>].nodeValue)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以通过for来遍历节点列表中的各个元素</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n遍历各个元素:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> person <span class="keyword">in</span> persons:</span><br><span class="line">    name = person.getElementsByTagName(<span class="string">&quot;name&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line">    gender = person.getAttribute(<span class="string">&quot;gender&quot;</span>)</span><br><span class="line">    id_number = person.getElementsByTagName(<span class="string">&quot;id&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue</span><br><span class="line">    tel = person.getElementsByTagName(<span class="string">&quot;tel&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue</span><br><span class="line">    address = person.getElementsByTagName(<span class="string">&quot;address&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    province = address.childNodes[<span class="number">1</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line">    city = address.getElementsByTagName(<span class="string">&quot;city&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;姓名: %s\t性别: %s\tid: %s\t电话: %s\t地址: %s省%s市&quot;</span></span><br><span class="line">          % (name, gender, id_number, tel, province, city))</span><br></pre></td></tr></table></figure>
	</div>
<div class="right">
<figure class="highlight bash"><figcaption><span>控制台输出</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">读取文件路径: C:\Users\*****\Desktop\xmltest\testfile.xml</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">变量类型: &lt;class <span class="string">&#x27;xml.dom.minidom.Element&#x27;</span>&gt;</span><br><span class="line">根元素名: addressbook</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">变量类型: &lt;class <span class="string">&#x27;xml.dom.minicompat.NodeList&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">节点列表中某一个元素的类型: &lt;class <span class="string">&#x27;xml.dom.minidom.Element&#x27;</span>&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Jack性别: male</span><br><span class="line"></span><br><span class="line">Jack性别: male</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">tel: 10000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;class <span class="string">&#x27;xml.dom.minidom.Text&#x27;</span>&gt;</span><br><span class="line">&lt;class <span class="string">&#x27;xml.dom.minidom.Element&#x27;</span>&gt;</span><br><span class="line">&lt;DOM Element: name at 0x21cca71a700&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;class <span class="string">&#x27;xml.dom.minidom.Text&#x27;</span>&gt;</span><br><span class="line">Jack</span><br><span class="line"></span><br><span class="line">Jack</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">遍历各个元素:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">姓名: Jack	性别: male	<span class="built_in">id</span>: 01	电话: 10000	地址: Jiangsu省Nanking市</span><br><span class="line">姓名: Maria	性别: female	<span class="built_in">id</span>: 02	电话: 10001	地址: Anhui省Hefei市</span><br></pre></td></tr></table></figure>
	</div>
    <div class='clear'></div>
</div>
<div class="note warning"><p>警告：在笔者所用的环境下，<code>.childNodes</code>方法会将子元素与子元素之间生成的空格与换行当作空白文本节点并入节点列表，以至于得不到预期的获取元素的效果。个人认为还是最好用<code>.getElementsByTagName</code>获取元素节点列表再通过索引获得元素。</p>
</div>
<h3 id="写入-更新-追加、删除"><a class="header-anchor" href="#写入-更新-追加、删除"></a>写入/更新(追加、删除)</h3>
<p>  对于第一种情况，你需要调用<code>xml.dom.minidom.Document()</code>新建一个DOM对象。而在其他情况下，你只需要建立、删除或者更新元素节点或者文本内容节点的值，并挂在到对应的父元素上即可，代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.dom.minidom <span class="keyword">as</span> minidom</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">filepath = os.path.abspath(<span class="string">&quot;testfile.xml&quot;</span>)</span><br><span class="line">objectTree = minidom.parse(filepath)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取根元素(addressbook)</span></span><br><span class="line">rootElement = objectTree.documentElement</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建person元素并赋属性</span></span><br><span class="line">person = objectTree.createElement(<span class="string">&quot;person&quot;</span>)</span><br><span class="line">person.setAttribute(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;male&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 新建各个元素并设置文本内容</span></span><br><span class="line"><span class="comment"># 创建元素</span></span><br><span class="line">name = objectTree.createElement(<span class="string">&quot;name&quot;</span>)</span><br><span class="line"><span class="comment"># 创建文本节点</span></span><br><span class="line">name_text = objectTree.createTextNode(<span class="string">&quot;Xiaoming&quot;</span>)</span><br><span class="line"><span class="comment"># 将文本挂载在其元素之下</span></span><br><span class="line">name.appendChild(name_text)</span><br><span class="line"></span><br><span class="line">id_number = objectTree.createElement(<span class="string">&quot;id&quot;</span>)</span><br><span class="line">id_text = objectTree.createTextNode(<span class="string">&quot;03&quot;</span>)</span><br><span class="line">id_number.appendChild(id_text)</span><br><span class="line"></span><br><span class="line">tel = objectTree.createElement(<span class="string">&quot;tel&quot;</span>)</span><br><span class="line">tel_text = objectTree.createTextNode(<span class="string">&quot;10002&quot;</span>)</span><br><span class="line">tel.appendChild(tel_text)</span><br><span class="line"></span><br><span class="line">address = objectTree.createElement(<span class="string">&quot;address&quot;</span>)</span><br><span class="line">province = objectTree.createElement(<span class="string">&quot;province&quot;</span>)</span><br><span class="line">province_text = objectTree.createTextNode(<span class="string">&quot;Hubei&quot;</span>)</span><br><span class="line">city = objectTree.createElement(<span class="string">&quot;city&quot;</span>)</span><br><span class="line">city_text = objectTree.createTextNode(<span class="string">&quot;Wuhan&quot;</span>)</span><br><span class="line">address.appendChild(province)</span><br><span class="line">address.appendChild(city)</span><br><span class="line">province.appendChild(province_text)</span><br><span class="line">city.appendChild(city_text)</span><br><span class="line"></span><br><span class="line">person.appendChild(name)</span><br><span class="line">person.appendChild(id_number)</span><br><span class="line">person.appendChild(tel)</span><br><span class="line">person.appendChild(address)</span><br><span class="line"></span><br><span class="line">rootElement.appendChild(person)</span><br><span class="line"></span><br><span class="line">persons = rootElement.getElementsByTagName(<span class="string">&quot;person&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;\n遍历各个元素:&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> p <span class="keyword">in</span> persons:</span><br><span class="line">    name = p.getElementsByTagName(<span class="string">&quot;name&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line">    gender = p.getAttribute(<span class="string">&quot;gender&quot;</span>)</span><br><span class="line">    id_number = p.getElementsByTagName(<span class="string">&quot;id&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue</span><br><span class="line">    tel = p.getElementsByTagName(<span class="string">&quot;tel&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue</span><br><span class="line">    address = p.getElementsByTagName(<span class="string">&quot;address&quot;</span>)[<span class="number">0</span>]</span><br><span class="line">    province = address.getElementsByTagName(<span class="string">&quot;province&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line">    city = address.getElementsByTagName(<span class="string">&quot;city&quot;</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].data</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;姓名: %s\t性别: %s\tid: %s\t电话: %s\t地址: %s省%s市&quot;</span></span><br><span class="line">          % (name, gender, id_number, tel, province, city))</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;modified.xml&#x27;</span>, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="comment"># 参数列表：文件 - 子元素缩进 - 编码 - 同级子元素之间插入的元素</span></span><br><span class="line">    objectTree.writexml(f, addindent=<span class="string">&#x27;  &#x27;</span>, encoding=<span class="string">&#x27;utf-8&#x27;</span>, newl=’\n’)</span><br></pre></td></tr></table></figure>
<p>  根据笔者测试，其能生成对应的元素，逻辑结构虽然没有发生错误：</p>
<figure class="highlight bash"><figcaption><span>控制台输出</span></figcaption><table><tr><td class="code"><pre><span class="line">遍历各个元素:</span><br><span class="line">姓名: Jack	性别: male	<span class="built_in">id</span>: 01	电话: 10000	地址: Jiangsu省Nanking市</span><br><span class="line">姓名: Maria	性别: female	<span class="built_in">id</span>: 02	电话: 10001	地址: Anhui省Hefei市</span><br><span class="line">姓名: Xiaoming	性别: male	<span class="built_in">id</span>: 03	电话: 10002	地址: Hubei省Wuhan市</span><br></pre></td></tr></table></figure>
<p>  但仍存在其问题，由于读取XML文件时，元素之间的换行符与空格被当作文本内容(在DOM下同样被视作元素)，从而<code>.writexml</code>参数中的换行、缩进同样对其生效，导致新加的元素格式正常，而原来排版工整的元素出现了格式问题：</p>
<p><img data-src="/img/2021-10-12-Use-Python-to-Read-and-Write-XML-files/01.png" alt="换行" title="换行问题"></p>
<div align="center">换行问题</div>
<br>
<p><img data-src="/img/2021-10-12-Use-Python-to-Read-and-Write-XML-files/02.png" alt="正常" title="正常效果"></p>
<div align="center">正常效果</div>
<h2 id="03-SAX解析XML文件"><a class="header-anchor" href="#03-SAX解析XML文件"></a>03 SAX解析XML文件</h2>
<p>  SAX，全称为Simple API for XML，它并非W3C官方所指定的一种标准，但是凭着其独特的事件处理模型，支持它的XML解析器也不在少数。与DOM相比，它的优势在于边解析边进行操作，不用像DOM一样将XML文件的整个对象树映射进内存中，占用资源较少。但缺陷在于需要用户自己动手重写回调函数（handler）以实现指定的操作，且根据我自己搜索到的资料，似乎SAX对于修改文件的数据——特别是指定位置的数据比较困难，中文资料可供参考的不多，而且大多是给的例子一模一样……</p>
<p>  SAX包括readers、handlers以及input sources三个部分。readers负责读取sources里的内容，并在遇到标签开始/结束/内容时向handler发送对应的事件。而handler负责处理对应的事件，相关代码可以在<code>.\Python\Python[版本号]\Lib\xml\sax\handler.py</code>中看到。</p>
<p>  SAX定义了四种handler，即content handler、DTD handler、error handler以及entity handler。笔者所学尚浅，只需要对xml文件中的内容进行处理即可。因此我们只需要重写content handler的类方法以执行我们需要的操作。</p>
<figure class="highlight python"><figcaption><span>重写回调函数</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># 重写Handler类，继承自xml.sax.ContentHandler</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XmlHandler</span>(xml.sax.ContentHandler):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.currentData = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.gender = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.name = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.<span class="built_in">id</span> = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.province = <span class="string">&quot;&quot;</span></span><br><span class="line">        self.city = <span class="string">&quot;&quot;</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 遇到元素的开始标签&lt;...&gt;时调用，tag是标签名字，attribute是属性值字典    </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">startElement</span>(<span class="params">self, tag, attribute</span>):</span><br><span class="line">        self.currentData = tag</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&quot;person&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;******&quot;</span>)</span><br><span class="line">            self.gender = attribute[<span class="string">&quot;gender&quot;</span>]</span><br><span class="line">            <span class="keyword">if</span> self.gender == <span class="string">&quot;male&quot;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;男性:&quot;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;女性:&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        </span><br><span class="line">	<span class="comment"># 遇到元素的结束标签&lt;/...&gt;时调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">endElement</span>(<span class="params">self, tag</span>):</span><br><span class="line">        <span class="keyword">if</span> tag == <span class="string">&quot;name&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;姓名:&quot;</span>, self.name)</span><br><span class="line">        <span class="keyword">elif</span> tag == <span class="string">&quot;id&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;id:&quot;</span>, self.<span class="built_in">id</span>)</span><br><span class="line">        <span class="keyword">elif</span> tag == <span class="string">&quot;province&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;省份:&quot;</span>, self.province)</span><br><span class="line">        <span class="keyword">elif</span> tag == <span class="string">&quot;city&quot;</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;市区:&quot;</span>, self.city)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">        self.currentData = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遇到元素的内容时调用</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">characters</span>(<span class="params">self, content</span>):</span><br><span class="line">        <span class="keyword">if</span> self.currentData == <span class="string">&quot;name&quot;</span>:</span><br><span class="line">            self.name = content</span><br><span class="line">        <span class="keyword">elif</span> self.currentData == <span class="string">&quot;id&quot;</span>:</span><br><span class="line">            self.<span class="built_in">id</span> = content</span><br><span class="line">        <span class="keyword">elif</span> self.currentData == <span class="string">&quot;province&quot;</span>:</span><br><span class="line">            self.province = content</span><br><span class="line">        <span class="keyword">elif</span> self.currentData == <span class="string">&quot;city&quot;</span>:</span><br><span class="line">            self.city = content</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>  然后我们来实战验证一下我们的代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> xml.sax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">XmlHandler</span>(xml.sax.ContentHandler):</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 创建并返回一个解析器对象(SAX XMLReader)</span></span><br><span class="line">parser = xml.sax.make_parser()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭namespaces模式，即取消对xml文件中命名空间的处理</span></span><br><span class="line">parser.setFeature(xml.sax.handler.feature_namespaces, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置当前的ContentHandler为自己重写的Handler</span></span><br><span class="line">handler = XmlHandler()</span><br><span class="line">parser.setContentHandler(handler)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 开始解析xml文件</span></span><br><span class="line">parser.parse(<span class="string">&quot;testfile.xml&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>效果展示：</p>
<figure class="highlight bash"><figcaption><span>控制台输出</span></figcaption><table><tr><td class="code"><pre><span class="line">******</span><br><span class="line">男性:</span><br><span class="line">姓名: Jack</span><br><span class="line"><span class="built_in">id</span>: 01</span><br><span class="line">省份: Jiangsu</span><br><span class="line">市区: Nanking</span><br><span class="line">******</span><br><span class="line">女性:</span><br><span class="line">姓名: Maria</span><br><span class="line"><span class="built_in">id</span>: 02</span><br><span class="line">省份: Anhui</span><br><span class="line">市区: Hefei</span><br></pre></td></tr></table></figure>
<h2 id="04-ElementTree解析XML文件"><a class="header-anchor" href="#04-ElementTree解析XML文件"></a>04 ElementTree解析XML文件</h2>
<h3 id="施工中。。。"><a class="header-anchor" href="#施工中。。。"></a>施工中。。。</h3>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习基础#00：Intro</title>
    <url>/2022/03/08/Machine-Learning-101-00/</url>
    <content><![CDATA[<style>
table
{
    margin: auto;
}
</style>
<p>  决定对近期学习到的机器学习相关知识进行一次整理。</p>
<span id="more"></span>
<p>  免责声明：本人对机器学习领域所知甚少，所写博文为对前期所学知识的回顾，不确保其内容的真实性与准确性，不建议以此为基础进行学习。如有差错纰漏，欢迎指正。</p>
<h2 id="什么是机器学习？"><a class="header-anchor" href="#什么是机器学习？"></a>什么是机器学习？</h2>
<p>  学习，就是从已有的经验（不论是亲自动手实践获得的，还是从书本上阅读得到的或者依赖老师教育所得到的）中获取知识的过程。机器学习也是类似的。如果让我下一个粗浅直接的定义，那就是：</p>
<blockquote><p>从已有的样本（数据）中发现规律，并能够将其泛化应用于未知的（或者说：新的）样本上。</p>
<footer><strong>Zh某</strong><cite><a href="https://zhmou.github.io/2022/03/08/Machine-Learning-101-00/#more">zhmou.github.io/2022/03/08/Machine-Learning-101-00/#more</a></cite></footer></blockquote>
<br>
<p>  譬如，从数千张形态各异的标注好数字标签的手写数字图片中发现规律，并最终能够实现识别输入数字的功能。</p>
<p><img data-src="/img/2022-3-9-Machine-Learning-101/Figure_1.png" alt="MNIST数据集图片识别"></p>
<div align='center' style="font-size: 14px; color: grey">一个多分类全连接神经网络在MNIST数据集上的测试表现</div>
<br>
<h2 id="一个简单的例子"><a class="header-anchor" href="#一个简单的例子"></a>一个简单的例子</h2>
<p>  现在，我们有一组$x$与$y$如表所示：</p>
<table>
<thead>
<tr>
<th style="text-align:center">x</th>
<th style="text-align:center">y</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">4</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">6</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">?</td>
</tr>
</tbody>
</table>
<p>  对于这两者已知的数据，我们需要从中发现$y$与$x$的规律，并预测在$x$=4时$y$的预测值$\hat{y}$。</p>
<p>  基于此，我们建立一个简单的线性模型：<br>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_2.png" alt="线性模型"></p>
<p>  此外，我们还需要一个“打分”的函数来评估模型在当前样本（所谓样本，结合这个例子来说就是上述列表里的某一行）上的“优劣”，称作：Loss function（损失函数）。在全体样本上（或者一个mini-batch中的所有样本，关于mini-batch，后面会详细解释），又可称作cost function（代价函数）这里，我们选择用均方误差（Mean Squared Error，MSE）来作为代价函数：即loss为模型预测值与真实值差值的平方。</p>
<p>$$<br>
loss={(\hat{y}-y)}^2<br>
$$</p>
<p>  大多数情况下，我们的目标是令代价函数的值尽可能的变小，即预测值接近真实值。</p>
<p>  现在，我们随机地初始化一组$w$和$b$($w=1,b=1$)来计算损失函数loss的值：<br>
  $x=2$时，$\hat{y}=3$，则$\left.loss\right|_{x=2}={(\hat{y}-y)}^2={(3-4)}^2=1$<br>
  $x=3$时，$\hat{y}=4$，则$\left.loss\right|_{x=3}={(\hat{y}-y)}^2={(4-6)}^2=4$<br>
  在全体样本上的均方误差$cost = 5\div2=2.5$</p>
<p>  我们把这个步骤称作“<strong>前向运算</strong>”/“<strong>前馈运算</strong>”，cost的值较大，表明随机初始化找到的参数并不能准确找到需要的规律。<br>
  在高中学习里，我们就已经知道，在一个连续光滑的函数上，当自变量沿着该点导数值的负方向移动一小段距离时，函数值会变小（如下图所示）。</p>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_3.png" alt="导数" style="float:center"/>
<p>  将其应用于我们的例子中：当我们将两个参数$w、b$沿着loss函数对其各自的偏导的负方向移动一小段距离后，loss函数的值会变小，进而在整体样本上cost函数的值也会变小。</p>
<p>  根据链式求导法则：<br>
$$<br>
\frac{\partial{loss}}{\partial{w}}=\frac{\partial{loss}}{\partial{\hat{y}}}\cdot\frac{\partial{\hat{y}}}{\partial{w}}=2(\hat{y}-y)\cdot{x}<br>
$$<br>
  (对b的偏导同理)</p>
<p>  将前向运算中计算得到的$\hat{y}$和当前样本已知的$x、y$带入上述式子可得：<br>
  在$x=2$时，$\left.{\frac{\partial{loss}}{\partial{w}}}\right|_{x=2}=−4$，$\left.{\frac{\partial{loss}}{\partial{b}}}\right|_{x=2}=−2$<br>
  在$x=3$时，$\left.\frac{\partial{loss}}{\partial{w}}\right|_{x=3}=-12$，$\left.\frac{\partial{loss}}{\partial{b}}\right|_{x=3}=−4$</p>
<p>  接下来，更新权重w与b的值，为了避免自变量变化得过大导致得不到我们想要得结果（如下图所示），我们需要控制自变量变化的步幅，即学习率（learning rate），此处设为lr = 0.04。</p>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_4.png" alt="导数" style="float:center"/>
<p>$$<br>
\begin{align*}<br>
w'&amp;=w-lr\cdot\frac{\partial{loss}}{\partial{w}}(avg.\ on\ all\ samples)\\<br>
&amp;=w- lr\cdot(\left.\frac{\partial{loss}}{\partial{w}}\right|_{x=2}+\left.\frac{\partial{loss}}{\partial{w}}\right|_{x=3})\div2\\<br>
&amp;=1-0.04\times(-4-12)\div2\\<br>
&amp;=1.32<br>
\end{align*}<br>
$$</p>
<p>  同理，$b$的值计算结果为：<br>
$$<br>
\begin{align*}<br>
b'&amp;=b-lr\cdot\frac{\partial{loss}}{\partial{b}}(avg.\ on\ all\ samples)\\<br>
&amp;=b-lr\cdot(\left.\frac{\partial{loss}}{\partial{b}}\right|_{x=2}+\left.\frac{\partial{loss}}{\partial{b}}\right|_{x=3})\div2\\<br>
&amp;=1-0.04\times(-2-4)\div2\\<br>
&amp;=1.12<br>
\end{align*}<br>
$$</p>
<p>  如上述的这个过程，被称为“反向传播”。这样，我们便走完了神经网络训练的一个轮次（Epoch）。此时，重新计算预测值、loss与cost，更新权重后的结果为：</p>
<p>  $x=2$时，$\hat{y}=3.76$，则$\left.loss\right|_{x=2}={(\hat{y}-y)}^2={(3.76-4)}^2=0.0576$<br>
  $x=3$时，$\hat{y}=5.08$，则$\left.loss\right|_{x=3}={(\hat{y}-y)}^2={(5.08-6)}^2=0.8464$<br>
  在全体样本上的均方误差$cost' = 0.452$</p>
<p>  显然，更新后的模型比其更新前能够更好地把握样本数据间的内在规律。在这一轮次的基础上，我们还可以继续重复训练的过程，在经过第二次训练后，得到$w'=1.644$，$b'=1.236$</p>
<p>  现在，对于例子开头提出来的问题，在经过两轮训练后，神经网络给出的$x=4$时的预测结果为:<br>
$$<br>
ŷ = 1.644\times4+1.236 = 7.812<br>
$$</p>
<p>  当反复训练后，cost的值趋近于零，在某个区间内呈现波动的时候，我们称这个网络<strong>收敛</strong>，而当cost值不再变小而且和0相去较远时，则可能陷入了局部最优解，或者是学习率过大导致无法收敛于全局最优解。</p>
<blockquote>
<p><strong>小结</strong><br>
神经元：网络中负责某种基础运算的单元。例如本例中建模采用的$y=kx+b$就是一个基础的神经元。<br>
神经网络训练的步骤：正向运算求Loss，反向计算求Loss对各个参数的偏导，依赖偏导对参数进行微小的调整。在本例中，反复以样本训练较好地逼近了结果。<br>
<strong>问题</strong>：<br>
多个线性神经元简单叠加，如两个神经元：$y = w_1(w_2x+b_2)+b_1 = w_1w_2x+w_1b_2+b_1$ ，仍与单个神经元效果相同，需要引入<em>非线性变换</em>才能较好的拟合非线性函数。</p>
</blockquote>
<h2 id="更复杂的例子"><a class="header-anchor" href="#更复杂的例子"></a>更复杂的例子</h2>
<p>  下方是某商品的评价及其人工标注的情感标签，试建立模型分析其中关系。</p>
<table>
<thead>
<tr>
<th style="text-align:center">评价</th>
<th style="text-align:center">情感标签</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">“好看”</td>
<td style="text-align:center">正面</td>
</tr>
<tr>
<td style="text-align:center">“不好”</td>
<td style="text-align:center">负面</td>
</tr>
<tr>
<td style="text-align:center">“好”</td>
<td style="text-align:center">正面</td>
</tr>
<tr>
<td style="text-align:center">“不好看”</td>
<td style="text-align:center">负面</td>
</tr>
<tr>
<td style="text-align:center">……</td>
<td style="text-align:center">……</td>
</tr>
</tbody>
</table>
<p>  由于神经网络只能接受数字化的输入并产生相对应的数字化输出，因此需要将这些样本转化成数据：</p>
<p>  首先提取基本语素，在这个简单的任务中，共有三个字：{好，不，看}<br>
  对这三个字进行“<strong>独热编码</strong>”：<br>
  <strong>好 = [1, 0, 0] 不 = [0, 1, 0] 看 = [0, 0, 1]</strong><br>
  输入样本的向量即为各个字符编码的相加，例如：<br>
  <strong>好看 = [1, 0, 1] 不好 = [1, 1, 0] ……</strong><br>
  对于输出，由于只存在两种标签，因此编码为：<br>
  <strong>正面 = [1, 0] 负面 = [0, 1]</strong><br>
  依照上述步骤，我们构造出了一个$4×3$(样本数×input size/基本语素单位)的输入矩阵$x$与$4×2$(样本数×标注类别)的标注矩阵$y$：<br>
$$<br>
x=\begin{bmatrix} 1 &amp; 0 &amp; 1 \\ 1 &amp; 1 &amp; 0 \\ 1 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1\end{bmatrix} y=\begin{bmatrix} 1 &amp; 0 \\ 0 &amp; 1 \\ 1 &amp; 0 \\ 0 &amp; 1\end{bmatrix}<br>
$$</p>
<p>  类似于第二部分中给出的例子，我们设计出一个相较于前者更为复杂的网络：<br>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_5.png" alt="网络" style="float:center" width="800px"/></p>
<p>  在两个隐藏层向各个下一层神经元传输相应数字时(箭头所示位置)，需要引入非线性变换的激活函数(Activation function)，这里选用的是Sigmoid函数：$𝑆(𝑥)=\frac{1}{(1+𝑒^{−𝑥})}$，它将实数域R的数字映射至(0, 1)内。网络最后一层的Softmax函数也是一种非线性变换，它将该层所有结果都映射到(0, 1)内，不改变大小的相对位置。对于该层的各个元素$x_i$，经变换后的值计算如下：<br>
$$<br>
softmax\ value = \frac{e^{x_i}}{\sum_{j}e^{x_j}{}}<br>
$$</p>
<p>  图中实线连接的部分就是我们在反向算法过程中需要更新的权重，为简化计算，在这个例子中我们忽略bias项即偏置的影响(也就是说每一条线代表的基础运算单元仅仅是$y=kx$)，只考虑权重w构成的三个矩阵：<br>
  $𝑤_1$为三行两列矩阵，$𝐻_1=𝑥𝑤_1$，$𝑤_2$ 、$𝑤_3$ 为两行两列的矩阵： $𝐻_2=𝑠𝑖𝑔𝑚𝑜𝑖𝑑(𝐻_1 ) 𝑤_2$，$𝑂𝑢𝑡𝑝𝑢𝑡=𝑠𝑖𝑔𝑚𝑜𝑖𝑑(𝐻_2)𝑤_3$</p>
<p>  <strong>正向运算：</strong><br>
  首先初始化三个矩阵$𝑤_1$ 、$𝑤_2$ 、$𝑤_3$，这里我调用了matlab的rand()函数来随机生成这三个矩阵：<br>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_6.png" alt="初始化及正向运算" style="float:center"/></p>
<p>  <strong>计算Loss：</strong><br>
  在二分类或者多分类问题上，我们常选用NLL loss(Negative log-likelihood loss，负对数似然损失)函数作为损失函数，该损失函数的具体计算过程如下：<br>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_7.png" alt="Loss计算" style="float:center"/></p>
<p>  <strong>反向传播：</strong><br>
  这一部分公式太多，懒得用$\LaTeX$再整理一遍，直接借用之前自己做的PPT里面的推导过程（不过说起来这里面的矩阵转置当时弄得我有些晕，其实你需要弄清楚对应元素的位置就比较清楚了。）：<br>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_8.png" alt="反向传播" style="float:center" width="800px"/></p>
<p>  <strong>更新权重：</strong><br>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_9.png" alt="反向传播" style="float:center" width="800px"/></p>
<blockquote>
<p><strong>小结与反思</strong><br>
同单层模型一样，多层模型仍采用反向传播算法来进行权重的更新。<br>
引入sigmoid、softmax等非线性变换来构筑更复杂的模型。<br>
损失计算采用了负对数似然损失(能否采用MSE，为什么？)<br>
对于文本序列而言，其出现的顺序对于理解其含义是至关重要的，简单向量相加丢失了字符出现顺序的信息。(改进：RNN)<br>
层数越深，由链式法则相乘得到的梯度越来越小，可能出现梯度消失的问题(改进：ResNet)<br>
文本的编码方式——独热编码的缺点在于①维数太高，考虑一个大型的语料库，出现的常用汉字数千，这种编码方式需要数千维的向量来表示一个句子（而且其中的大部分元素都是0）。②（基于前者）大部分句子的向量都分布在坐标轴附近。③（基于前者）难以衡量两个句子之间的相似度。</p>
</blockquote>
<h2 id="随机梯度下降：引入Mini-Batch"><a class="header-anchor" href="#随机梯度下降：引入Mini-Batch"></a>随机梯度下降：引入Mini-Batch</h2>
<p>  对于梯度下降，有几种不同的方法对其进行实现：<br>
  批量梯度下降：计算所有样本的loss后，再更新权重w与偏置b。<br>
  随机梯度下降：从全体样本中随机抽取一个样本，计算loss后更新权重w与偏置b，直到抽取完所有样本后跑完一个轮次。<br>
  小批量(随机)梯度下降：将全体样本划分为若干个mini-batch，每个batch中存在若干样本，随机抽出一个mini-batch，计算该批次样本中的loss后更新权重w与偏置b，直到跑完所有mini-batch后，记作训练一个轮次。在训练完一个轮次后。对样本进行shuffle处理，即重新划分mini-batch，再次进行训练，形象化的比喻可以称作“洗牌”，这也是为什么英文叫做&quot;shuffle&quot;。</p>
<img data-src="/img/2022-3-9-Machine-Learning-101/Figure_10.png" alt="三种方法" style="float:center" width="800px"/>
<p>  三种不同方式的对比：<br>
  一般来说，小批量梯度下降通过选取部分样本引入了更大噪声，使得它在解空间的“鞍点”位置更容易受噪声扰动，在一些情况下性能表现比批量梯度下降更好。而随机梯度下降更新权重只关注当前样本的梯度，所以尽管每一步使得当前样本得到最优的表现，但从整体样本考虑则不一定最优，且每一个样本前向计算时都需要依赖上一个样本反向传播后更新的权重，并行化程度不如其它两者高。<br>
  形象化的三种方式如上图所示，红点位置即为所求的最优解，图中带箭头的线则显示了这三种方法在寻找最优解的过程。</p>
<hr>
&emsp;&emsp;这篇文章，笔者简要回顾了机器学习的最基础内容，虽然听起来或者推导起来比较复杂。但作为感性的认知来看，了解机器学习的工作原理并不困难，甚至完全可以只用高中的知识理解。本期的内容还未涉及到代码部分，这些工作将在下期进行介绍。
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>一个实现注册、激活的软件Demo</title>
    <url>/2021/10/31/A-Register-Toy-Demo/</url>
    <content><![CDATA[<p>  一般而言，我的需求大多来自实验室，这次也不例外。由于实验室经常承接某些外包的横向项目，因此实验室需要一个能对项目软件进行加密注册的功能以期实现售卖激活码的方式收费盈利。实验室里之前本来就有这玩意儿，但其由C++实现得即为复杂，加之多年来删改维护，让我第一次直观体会到了“屎山”的威力。于是我觉得还不如自己写个Python的Demo玩玩，所谓“功在当代，利在千秋”是也。</p>
<p>  GitHub项目地址：<a href="https://github.com/zhmou/RegisterDemo">https://github.com/zhmou/RegisterDemo</a></p>
<span id="more"></span>
<h2 id="构建模型"><a class="header-anchor" href="#构建模型"></a>构建模型</h2>
<p>  <del>稍有常识的人就能看出</del>……反正对于有经验的网友而言，尽管软件注册有着本地注册、网络激活、激活码等等不同的形式，但本质上大多都万变不离其宗：软件读取一段指定的加密信息用于激活（授权），并确保该信息不能（或者几乎不能）被伪造（用于重复激活多台设备或者是伪装激活）。序列号+激活码就是这样一种常见的模式：</p>
<p>图片待补，反正是一张描述软件注册流程的图片。</p>
<p>  由图可知，我们要实现的需求有以下几条：<br>
  <strong>客户端Client</strong><br>
  ①读取机器信息：生成唯一的机器设备标识（序列号）<br>
  ②判断注册状态：对于未注册的软件，则不允许使用该软件；判断注册信息是否异常<br>
  ③注册：结合上一步，对于未注册的软件，输入激活码注册，比对激活码是否与该设备的序列号匹配：匹配则生成对应注册信息，不匹配则提示错误。对于已注册的软件，防止重复注册。<br>
  ④时间信息读写：启动程序时，判断注册状态，注册则读取激活剩余时间，每隔相应的时间对注册信息进行修改，直到剩余时间为0则删除注册信息（或者写入已过期的提示信息）</p>
<p>  <strong>服务器端Client</strong><br>
  输入序列号，自动生成对应的激活码</p>
<p>  总之，这些东西的难度并不是很大，接下来将每一个提到的需求分别在客户端和服务端实现就好。</p>
<h2 id="唯一设备标识码UUID"><a class="header-anchor" href="#唯一设备标识码UUID"></a>唯一设备标识码UUID</h2>
<p>  目前，本项目采取的方式是调用命令行显示主板统一规范的smBIOS信息：</p>
<p>  <code>CURRENT_MACHINE_ID = subprocess.check_output('wmic csproduct get uuid').decode().split('\n')[1].strip().replace('-', '')</code></p>
<p>  直接调用命令行显示结果如下：<br>
<img data-src="/img/2021-10-31-A-Register-Toy-Demo/01.png" alt="命令行"></p>
<p>  在后面进行了一系列操作如<code>.spilt('\n')[1]</code>（取出以换行符为分割的元素），<code>.strip()</code>（去掉首尾的空格），<code>.replace('-', '')</code>（把连字符-去掉）等，最终生成了一个32位十六进制的字符串作为软件注册时机器的识别编码。</p>
<h3 id="其他方式获取标识码"><a class="header-anchor" href="#其他方式获取标识码"></a>其他方式获取标识码</h3>
<p>  上述方法的好处是调用简单，但是也留下了我曾忽视的隐患（当然是我自己的锅= =）：激活码在客户端只会与UUID进行匹配，激活码可能重复激活。之前的屎山代码里不仅根据机器特征，同时会根据时间生成一个序列号，因此避免了同一个激活码重复激活的可能。<br>
  根据我的检索，Python中<code>uuid.getnodes()</code>或许可以满足我的要求，当然效果具体如何得等到我的实验验证啦。</p>
<h2 id="核心：RSA加密算法"><a class="header-anchor" href="#核心：RSA加密算法"></a>核心：RSA加密算法</h2>
<p>  如何针对序列号生成一段加密序列，使得软件能还原出激活信息？我最初的想法很简单：服务端对序列号进行加密，客户端进行相同的加密方式，两者匹配上即视为注册成功。但是这样存在一个问题：倘若具备一定反编译能力的人找到了客户端里隐藏的加密算法，那就等同于掌握了注册机——他能算出任意序列号对应的激活码，而这就对我们极为不利了。</p>
<p>  好在数学的发展让我们有了非对称加密的概念：</p>
<blockquote><p>公开密钥密码学（英语：Public-key cryptography）也称非对称式密码学（英语：Asymmetric cryptography）是密码学的一种算法，它需要两个密钥，一个是公开密钥，另一个是私有密钥；公钥用作加密，私钥则用作解密。</p>
<footer><strong>Wikipedia</strong><cite><a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E5%BC%80%E5%AF%86%E9%92%A5%E5%8A%A0%E5%AF%86">公开密钥加密</a></cite></footer></blockquote>
<br>
&emsp;&emsp;除了加解密之外，非对称加密还具有数字签名的作用：采用私钥进行签名，公钥验证签名。于是我们可以用考虑在服务端用私钥来生成我们的激活码，而在客户端用公钥进行验证，这样两个密钥分离的形式就能免除上述说法提到的风险。
<p>  RSA算法就是一种知名的非对称加密算法，它基于大数因式分解的困难程度保证了安全性，以及拓展欧几里得算法快速求解不定方程的便捷使其具有可实现性。尽管我不甚理解算法的原理，但是根据步骤使用Python则很容易，RSA公钥、密钥生成步骤按照网上的说明如下：</p>
<blockquote><p>①随机选择两个不相等的质数p和q。<br>
②计算n = p*q（一般地，n(base 2)的长度被建议达到2048bit以达到要求的安全性）<br>
③计算n的欧拉函数φ(n)=(p-1)(q-1)<br>
④选择整数e满足1&lt;e&lt;φ(n)，且e与φ(n)互质(通常选择65536)<br>
（之前想了很久还在想万一65536与φ(n)不互质咋办……现在想想，直接重选呗！判断互质直接用辗转相除法就行啦）<br>
⑤计算e对于φ(n)的模反元素d，即ed / φ(n) 的余数 是 1<br>
⑥将n和e封装成公钥对，n和d封装成私钥对，并销毁p、q</p>
</blockquote>
<p>  本项目用到的签名与验签的步骤则要用到大数幂取模的快速算法：签名信息 = 待签名信息 ^ d % n；原信息 = 签名信息 ^ e % n</p>
<div class="note warning"><p>提示：待加密信息长度不能超过n的长度。</p>
</div>
<p>  整个核心部分密钥生成的代码参见此处：<a href="https://github.com/zhmou/RegisterDemo/blob/main/src/keygen.py">https://github.com/zhmou/RegisterDemo/blob/main/src/keygen.py</a></p>
<h3 id="模反元素d的计算——扩展欧几里得算法"><a class="header-anchor" href="#模反元素d的计算——扩展欧几里得算法"></a>模反元素d的计算——扩展欧几里得算法</h3>
<p>  欧几里得算法即辗转相除法：给定两个数a、b，计算 a ÷ b 的余数 a % b，并以此作为新的除数计算 b ÷ a % b，直到能够整除没有余数为止。这时候最后一项除法式子的被除数就是原来给定两数a、b的最大公约数（公因数，greatest common divisor）。Python实现如下：</p>
<figure class="highlight python"><figcaption><span>gcd(a,b)</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> a</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> gcd(b, a % b)</span><br></pre></td></tr></table></figure>
<p>  而扩展欧几里得算法则是用来求ax + by = gcd(a,b)的整数解x、y，而模反元素d是求ed + kφ(n) = 1的整数解d（考虑到e与φ(n)互质, gcd(e,φ(n))=1），所以d可以通过扩展欧几里得算法来计算，原理及Python实现如下：</p>
<p>  原理:设a&gt;b<br>
  当b=0时,gcd(a,0)=a,对于a=ax+0y,容易得到其正整数解x=1,y=0<br>
  当b!=0时,设:<br>
    ax1 + by1 = gcd(a,b)<br>
    bx2 + (a%b)*y2 = gcd(b,a%b)<br>
  根据辗转相除法的原理有 gcd(a,b) = gcd(b,a%b);两式联立得:<br>
    ax1 + by1 = bx2 + (a%b)*y2<br>
  而a%b可写作 a - (a//b) * b (其中&quot;//&quot;为整除),则有:<br>
    ax1 + by1 = bx2 + ay2 - (a//b)*by2<br>
  比对系数可得:<br>
    x1 = y2<br>
    y1 = x2 - (a//b)*y2</p>
<p>  由此可知，方程gcd(a, b) = ax1 + by1的解可用gcd(b, a%b) = bx2 + (a%b)y2表示，<br>
  构成了类似欧几里得算法的递归，下述函数即通过递归的方式实现了拓展欧几里得算法。</p>
<figure class="highlight python"><figcaption><span>extend_gcd()</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">extend_gcd</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">if</span> b == <span class="number">0</span>:</span><br><span class="line">        x1 = <span class="number">1</span></span><br><span class="line">        y1 = <span class="number">0</span></span><br><span class="line">        x = x1</span><br><span class="line">        y = y1</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        x1, y1 = extend_gcd(b, a % b)</span><br><span class="line">        x = y1</span><br><span class="line">        y = x1 - a // b * y1</span><br><span class="line">        <span class="keyword">return</span> x, y</span><br></pre></td></tr></table></figure>
<h3 id="快速幂取模算法"><a class="header-anchor" href="#快速幂取模算法"></a>快速幂取模算法</h3>
<p>  <strong>施工中</strong></p>
<h2 id="其它tricks"><a class="header-anchor" href="#其它tricks"></a>其它tricks</h2>
<h3 id="进制转换：压缩激活码长度"><a class="header-anchor" href="#进制转换：压缩激活码长度"></a>进制转换：压缩激活码长度</h3>
<p>  在RSA加密算法中，我们实际上是对十进制数字进行签名处理。尽管UUID是十六进制字符串，但Python内自带的函数就能将其转换为十进制数字进行签名或者验签。然而只要你尝试过签名函数，结果会发现它生成的十进制数字签名长得难以想象，因此我进行了折中处理：一方面缩短n的长度来牺牲其安全性以换取长度的缩短。另一方面对于其十进制签名，我们可以将其转换为62进制（用0-9、a-z以及A-Z来表示）来压缩其长度，这部分代码就需要自身实现了，其思路是以十进制为桥梁，先将自身进制转换为十进制，再转换到目标进制。</p>
<p>  进制转换的代码参见此处：<a href="https://github.com/zhmou/RegisterDemo/blob/main/src/baseconvert.py">https://github.com/zhmou/RegisterDemo/blob/main/src/baseconvert.py</a></p>
<h3 id="添加时间信息"><a class="header-anchor" href="#添加时间信息"></a>添加时间信息</h3>
<p>  思路没啥特别的，就是对待签名信息的指定位置上添加激活时长，我的方法是激活时长（天数）格式化为四位：如 30天 -&gt; 0030，字符串拼接在待签名信息的后面，这样激活的时候读取到该字符串就能正确初始化注册信息文件里的时间了。</p>
<h3 id="PyQt5的可视化与多线程处理"><a class="header-anchor" href="#PyQt5的可视化与多线程处理"></a>PyQt5的可视化与多线程处理</h3>
<p>  <strong>施工中</strong></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Python</tag>
        <tag>RSA算法</tag>
        <tag>软件注册</tag>
      </tags>
  </entry>
  <entry>
    <title>2021CVPR论文：Coordinate Attention</title>
    <url>/2022/05/04/2021-CVPR-Coordinate-Attention/</url>
    <content><![CDATA[<p>  论文标题：<a href="https://openaccess.thecvf.com/content/CVPR2021/papers/Hou_Coordinate_Attention_for_Efficient_Mobile_Network_Design_CVPR_2021_paper.pdf">Coordinate Attention for Efficient Mobile Network Design</a></p>
<p>  <a href="https://github.com/Andrew-Qibin/CoordAttention">Github链接</a></p>
<h2 id="摘要（翻译）"><a class="header-anchor" href="#摘要（翻译）"></a>摘要（翻译）</h2>
<p>  近年来对轻量级网络(mobile network)设计的研究表明，通道注意力机制(例如：Squeeze-and-Excitation attention, 压缩-激发注意力机制，出自<a href="https://arxiv.org/abs/1709.01507">SENet, CVPR2018</a>)对于模型性能的提升具有显著效果，但它们通常忽略掉了位置信息——这对于生成空间选择性注意力图(spatially selective attention maps)非常重要。在这篇文章中，我们针对轻量级网络提出了一种新的注意力机制，该机制将位置信息嵌入到通道注意力中。我们称其为 <strong>坐标注意力(Coordinate Attention)</strong> 机制。<br>
  不同于通道注意力将一个特征张量通过二维全局池化转换为单个特征向量，坐标注意力将通道注意力拆解为两个一维特征提取的过程，分别沿着两个空间方向(译注：宽，高)提取特征。通过这种方法可以提取一个空间方向上的远距离依赖关系，同时又可以在另一个空间方向上保持精确的位置信息。结果产生的特征图然后分别编码为一对方向感知(direction-aware)与位置敏感(position-sensitive)的注意力图，可以增补应用于输入的特征图来增强对感兴趣对象的表示。<br>
  我们的坐标注意力机制简单，可以灵活插入于经典的轻量级网络，如<em>MobileNetV2</em>, <em>MobileNeXt</em>和<em>EfficientNet</em>并且几乎没有额外的计算开销。大量实验表明，我们的坐标注意力机制在ImageNet分类上存在性能提升，更有趣的是，它在下游任务中表现更好，如目标检测和语义分割。</p>
<span id="more"></span>
<h2 id="回顾几种注意力机制"><a class="header-anchor" href="#回顾几种注意力机制"></a>回顾几种注意力机制</h2>
<h3 id="SENet"><a class="header-anchor" href="#SENet"></a>SENet</h3>
<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_1.png" alt="SENet" title="SENet" style="float:center"/>
<div class="comment">SENet的基础结构——压缩激励块</div>
<div class="comment">A Squeeze-and-Excitation block</div>
&emsp;&emsp;SENet所提出的注意力机制基本架构如上图所示：$F_{tr}$是可将输入$X$映射为特征图$U$的变换，其中$U\in\mathbb{R}^{H{\times}W{\times}C}$。例如，$F_{tr}$可以是常见的卷积操作。对于任意一个$F_{tr}$变换，都可以构造一个对应的SE块来进行特征重校准(feature recalibration, 即将特征图的各个通道赋以不同的权重)。
<p>  特征图$U$首先通过$F_{sq}$压缩(squeeze)为$1\times1{\times}C$的向量，将一个通道内所有的空间特征编码为该通道上的全局特征。在论文中，这一步操作是通过全局均值池化(Global Avarage Pooling, GAP)来实现的，即特征图各个通道上权值之和除以特征图的尺寸(宽×高)：<br>
<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/equation.svg" alt="GAP" title="GAP" style="float:center"/></p>
<div class="comment">全局均值池化</div>
&emsp;&emsp;然后这个向量再通过两个全连接层，得到各通道真正的权重。这个步骤被作者称作激励(excitation)。两个全连接层都拥有可训练参数，目的是通过所有样本的训练来学习到GAP产生的特征向量到各通道权重之间的关系。这两个全连接层的结构类似瓶颈结构(bottle beck): 第一个全连接层将向量压缩为$1\times1{\times}{C/r}$，随后经ReLU这一非线性变换后送入第二个全连接层，恢复为$1\times1{\times}{C}$，再送入Sigmoid激活函数——由于特征之间并不一定彼此互斥，因此这里没有采用Softmax。最后得到的权重和各个通道相乘得到特征重校准后的$\widetilde{X}$.
<p>  在激励这一环节中，瓶颈结构能有效降低参数量并提升泛化能力，$r$是一个超参数，称作降维系数(redution ratio)，$r$值的大小决定了SE块的容量(capacity)与计算开销。在论文中，作者采用SE-ResNet-50对$r$值大小进行了实验，在平衡性能与计算开销上，设置$r=16$能在两者之间产生平衡。在实践中，由于不同层承担不同的角色，因此整个网络的$r$值可根据需要调整以达到更好的性能。<br>
  SE模块的方便之处在于可以直接加入现有的骨干网络之上，例如将SE Block插入ResNet和Inception这两种骨干网络中：</p>
<div>
<div class="left"><img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_2.png" alt="SENet" title="SENet" style="float:center"/></div>
<div class="right"><img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_3.png" alt="SENet" title="SENet" style="float:center"/></div>
<div class="clear"></div>
</div>
<div class="comment">左图：SE-Inception 右图：SE-ResNet</div>
&emsp;&emsp;卷积训练出来的结果也带有通道的权值，但是实际上，由于卷积核感受野的限制，特征图中各个通道上每一个$H\times{W}$的权重参数，不仅仅有通道上的相关性，还受空间邻域相关性的影响。因此在SE结构中，作者先是采用全局均值池化消去了卷积捕捉到的空间依赖，在排除掉了空间依赖的影响后剩下了通道的影响。因此可以通过全连接来训练获取各个通道的权重。
<h3 id="CBAM-Convolutional-Block-Attention-Module-ECCV-2018"><a class="header-anchor" href="#CBAM-Convolutional-Block-Attention-Module-ECCV-2018"></a><a href="https://openaccess.thecvf.com/content_ECCV_2018/papers/Sanghyun_Woo_Convolutional_Block_Attention_ECCV_2018_paper.pdf">CBAM: Convolutional Block Attention Module (ECCV 2018)</a></h3>
<p>  在SENet中，作者只考虑了通道维度上的权重。而卷积操作本身是通过跨通道信息和空间信息混合在一起来提取信息特征的。因此，在CBAM的模块中；作者考虑在空间和通道两个维度上分别应用注意力机制，来使模型学习到在通道维度上“注意什么”和空间维度上“注意哪里”。<br>
<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_4.png" alt="CBAM Overview" title="CBAM Overview" style="float:center" width="800px"/><div class="comment">CBAM总体结构</div>  上图是CBAM的总体概览，该部分存在两个子模块：通道注意力模块和空间注意力模块。输入的特征图同SE模块类似，经通道注意力模块进行重校准后送入空间注意力模块。再次得到空间上的权重后同特征图相乘得到最终的结果。<br>
  CBAM对于两个模块的安排是经过实验验证的结果。在4.1节的消融实验中，作者发现：顺序（串行）安排两个子模块所生成的注意力图比并行安排两个子模块的注意力图更加精细；优先通过通道注意力模块的性能比优先通过空间注意力模块更好；此外同时使用两种注意力模块在任何情况下都比单独使用通道注意力机制的结果更好（因此证明该结构的设计是有效的）。<br>
  对于更具体的模块结构，如下图所示：<br>
<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_5.png" alt="CBAM" title="CBAM" style="float:center" width="800px"/><div class="comment">CBAM具体结构</div>  同SE模块类似，但SENet的通道注意力机制不仅采用GAP，而且采用了全局极值池化(Global Max Pooling, GMP)来得到两个$1\times1{\times}C$的向量。这两个向量通过<strong>同一个</strong>两个全连接层构成的(同样是瓶颈结构的)MLP(作者称之为&quot;shared MLP&quot;)。在此之后两个向量通过逐元素求和得到单个向量，最后同样通过Sigmoid函数得到通道上的权重。算法公式如下：<br>
<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_6.png" alt="channel attention" title="channel attention" style="float:center" width="500px"/><div class="comment">通道注意力</div>  通过沿通道方向上做均值池化、极值池化，我们可以得到两个二维的特征图：$F_{avg}^s,\ F_{max}^s\in\mathbb{R}^{H\times{W}\times1}$。对这两个特征图，将其沿通道方向拼接得到${H\times{W}\times2}$的特征图，然后用$7\times7$大小的卷积核(周围一圈先进行padding操作以保持卷积后尺寸不变)卷积得到${H\times{W}\times1}$，最后经Sigmoid产生空间特征权重值。算法公式如下：<br>
<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_7.png" alt="spatial attention" title="spatial attention" width="500px" style="float:center"/><div class="comment">空间注意力</div>  在ResNet的基本结构：ResBlock中，应用CBAM机制如下：<br>
<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_8.png" alt="CBAM in ResNet" title="CBAM in ResNet" style="float:center"/><div class="comment">CBAM integrated with a ResBlock in ResNet</div></p>
<h2 id="CA注意力机制"><a class="header-anchor" href="#CA注意力机制"></a>CA注意力机制</h2>
<p>  由于轻量级网络的计算能力有限，任何带来巨大开销的注意力机制都是难以应用到现实的，因此目前最流行的轻量级网络的注意力机制仍然是SE。但是SE只考虑对通道信息计算权重，因此后来的注意力机制考虑通过压缩特征图的通道维度来利用位置信息，再通过卷积来计算空间注意力，然而卷积本身只捕获局部关系，不能对视觉任务必不可少的远程依赖关系(long-range dependencies)进行建模。<br>
  基于上述原因，作者一方面为了避免CBAM中首先进行通道注意力时采用GAP、GMP导致位置信息损失，同时考虑长距离依赖，提出了这种新颖的，将位置信息嵌入到通道注意力中的坐标注意力机制。其结构如下：<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_9.png" alt="CA Overview" title="CA Overview" style="float:center" width="500px"/><div class="comment">CA结构总览。注意，本文对特征图尺寸的描述是${H{\times}W{\times}C}$，与图片中把通道数放在第一位的表示略有不同。</div>   在H(Y)和W(X)方向上，分别进行一次均值池化。对于和我一样缺乏直觉的朋友可以建立左手坐标系，想象一个${H{\times}W{\times}C}$的立方体，沿Y方向投影，得到的结果自然是${1{\times}W{\times}C}$的图；沿X方向投影，得到的结果是${H{\times}1{\times}C}$的图。在这两个图上，为了使其能够顺利地在一个平面上拼接，需要将其中一张变化到另一个平面上。以下是我用鼠标绘制的一张更直观的图：<img data-src="/img/2022-05-04-2021-CVPR-Coordinate-Attention/Figure_10.png" alt="CA Overview" title="CA Overview" style="float:center" width="600px"/><div class="comment">鼠标绘制</div>  拼接得到的结果是$1\times{(H+W)}\times{C}$或者${(H+W)}\times1\times{C}$。这取决于把X Avg Pool横过来还是Y Avg Pool竖起来，但是<strong>注意</strong>：这里的通道数始终都是C，不要将这张图看作${(H+W)}\times{C}\times{1}$的情况，因此我在右侧的上方画了一只眼睛，代表从这个方向看。这对于下一步理解卷积的过程很有必要。<br>
  下一步是采用$1\times1$的卷积压缩通道数为$C/r$，接下来进行批归一化(Batch Normalization)，随后进行非线性变换——在这一步中，作者用的非线性变换似乎是自己改进的Swish激活函数：对于每个元素$x$，其经过激活值后的结果为$x\times{ReLU6(x+3)\ /\ 6}$，其中ReLU6是ReLU函数将最大值限制为6之后的结果：$ReLU6(x)=min(max(0,x),6)$。至于为什么用这个激活函数，作者在文章里面压根一点没提，只在3.2.2的公式(6)下方做了说明: δ is a non-linear activation function.<br>
  压缩完通道维度之后，作者又将拼接而来的两者进行Spilt分开了。在知乎上，我看到有人提到$x$和$y$两方向信息交互的问题，在进行思考之后，我个人认为上一步的拼接与卷积压缩维度的操作不能说是实现信息的融合，只能说是两者共用了同一组卷积核参数。行文至此，我觉得有必要动手试试，<strong>如果整个过程中不进行拼接操作会有什么样的效果。</strong>（不过最近有点懒也有些忙，或许有空了再试试。）<br>
  分开-恢复维度-Sigmoid激活函数，这样就得到了两组不同方向上的注意力权重。最后将这些权重与输入的特征图相乘（具体操作应该是这两个平面上的权重通过广播机制膨胀为三维矩阵，再进行点乘操作）就得到了经特征重校准后的特征图。<br>
  在消融实验中，作者在一些常见的轻量级网络上将原有的SE注意力机制替换为CA注意力机制，其结果都存在1%左右的提升。</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>机器学习</tag>
        <tag>论文研读</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣刷题小录</title>
    <url>/2022/09/11/Leetcode-log/</url>
    <content><![CDATA[<h1 id="基础"><a class="header-anchor" href="#基础"></a>基础</h1>
<h2 id="只出现一次的数字-丢失的数字-0-n-1中缺失的数字"><a class="header-anchor" href="#只出现一次的数字-丢失的数字-0-n-1中缺失的数字"></a><a href="https://leetcode.cn/problems/single-number/">只出现一次的数字</a> / <a href="https://leetcode.cn/problems/missing-number/">丢失的数字</a> / <a href="https://leetcode.cn/problems/que-shi-de-shu-zi-lcof/">0 ~ n-1中缺失的数字</a></h2>
<p><strong>简述：</strong><br>
  ①给定一个包含 [0, n] 中 n 个数的数组 nums，找出 [0, n] 这个范围内没有出现在数组中的那个数。(缺失的数字)<br>
  ②给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。(只出现一次的数字)<br>
<strong>思路：</strong><br>
  一个数字与它自身异或的结果为0，譬如3(011) ^ 3(011) = 0(000)，而0与任何数字异或的结果均为其自身。对于②而言，遍历数组，所有数字按位异或即可得到只出现过一次的数字。<br>
  而对于①来说，考虑一个长度为 2n+1 的数组，其中包含了一个nums数组（长度为n），另一部分则是 [0, n] 这 n+1 个数。很显然该数组中只有nums数组缺失的那一个数只出现过一次，剩余数字均出现过两次，因此此题可以转化为 <i>只出现一次的数字</i> 的做法。</p>
<span id="more"></span>
<p><strong>题解：</strong><br></p>
<div>
    <div class='left'>
<figure class="highlight javascript"><figcaption><span>①缺失的数字</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> missingNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i =<span class="number">0</span>; i &lt; nums.<span class="property">length</span> ; i++)&#123;</span><br><span class="line">        ans ^= i;</span><br><span class="line">        ans ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    ans ^= nums.<span class="property">length</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
    <div class='right'>
<figure class="highlight javascript"><figcaption><span>②只出现一次的数字</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> singleNumber = <span class="keyword">function</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="property">length</span>; i ++)&#123;</span><br><span class="line">        ret ^= nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
    <div class='clear'></div>
</div>
<h2 id="汉明重量-汉明距离"><a class="header-anchor" href="#汉明重量-汉明距离"></a><a href="https://leetcode.cn/problems/number-of-1-bits/">汉明重量</a> / <a href="https://leetcode.cn/problems/hamming-distance/">汉明距离</a></h2>
<p><strong>简述：</strong><br>
  ①编写一个函数，输入是一个无符号整数（以二进制串的形式），返回其二进制表达式中数字位数为 '1' 的个数（也被称为汉明重量）。<br>
  ②两个整数之间的 <i>汉明距离</i> 指的是这两个数字对应二进制位不同的位置的数目。给你两个整数 x 和 y，计算并返回它们之间的汉明距离。<br>
<strong>思路：</strong><br>
  ①当单个bit和1进行与运算的时候，该bit为1时结果为1，为0时则结果为0。则例如 11010 和 10000、01000、00100、00010、00001 进行 &amp;运算 时，结果为1时，计数变量 + 1，最后返回该计数变量即可。<br>
  ②两个数字异或运算结果的汉明重量即为汉明距离。<br>
<strong>题解：</strong></p>
<div>
    <div class='left'>
<figure class="highlight javascript"><figcaption><span>题解一</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((n &amp; (<span class="number">1</span> &lt;&lt; i)) !== <span class="number">0</span>) &#123;</span><br><span class="line">            ret++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
    <div class='right'>
<figure class="highlight javascript"><figcaption><span>题解二</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span> - a positive integer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> hammingWeight = <span class="keyword">function</span>(<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">        n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> k;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
    </div>
    <div class='clear'></div>
</div>
<div class="note warning"><p>题解二中用到的 <code>&gt;&gt;&gt;</code> 是 <i>无符号右移运算符</i>，左边空出位将用0填充。<br>
具体参见MDN：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Expressions_and_Operators</a><br>
否则在范例中，32位有符号数的最高位为1时，循环不会终止。</p>
</div>
<h2 id="进制转换-K进制表示下的各位数字总和-数字转换为16进制数"><a class="header-anchor" href="#进制转换-K进制表示下的各位数字总和-数字转换为16进制数"></a>进制转换 / <a href="https://leetcode.cn/problems/sum-of-digits-in-base-k/">K进制表示下的各位数字总和</a> / <a href="https://leetcode.cn/problems/convert-a-number-to-hexadecimal/">数字转换为16进制数</a></h2>
<p><strong>简述：</strong><br>
  ①给你一个整数 n（10 进制）和一个基数 k ，请你将 n 从 10 进制表示转换为 k 进制表示，计算并返回转换后各位数字的 总和 。转换后，各位数字应当视作是 10 进制数字，且它们的总和也应当按 10 进制表示返回。（K进制表示下的各位数字总和）<br>
  ②给定一个整数，编写一个算法将这个数转换为十六进制数。对于负整数，我们通常使用 <i>补码运算</i> 方法。</p>
<div class="note info"><p>注意:<br>
十六进制中所有字母(a-f)都必须是小写。<br>
十六进制字符串中不能包含多余的前导零。如果要转化的数为0，那么以单个字符'0'，来表示；对于其他情况，十六进制字符串中的第一个字符将不会是0字符。 <br>
给定的数确保在32位有符号整数范围内。<br>
不能使用任何由库提供的将数字直接转换或格式化为十六进制的方法。</p>
</div>
<p><strong>思路：</strong><br>
  10进制转 k 进制：10进制的数字 除以 k，得到的余数就是目标待转换的数字的最后一位，再拿刚刚所得到的商继续除以k，如此循环，直到所得的商为0。<br>
  对于题目②。特别地，对于32位有符号整数的表示，比如 -1 在32位有符号整数的表示，与无符号数下2<sup>32</sup>-1是一致的。<br>
  此外，由于16进制数中存在a~f，余数为10即对应a、11对应b……可利用这种方式将对应字符保存起来：<code>String.fromCharCode(余数-10 + 'a'.charCodeAt() //即a对应的ascii码)</code><br>
<strong>题解：</strong></p>
<div>
<div class='center'>
<figure class="highlight javascript"><figcaption><span>进制转换</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">BaseChange</span> = <span class="keyword">function</span> (<span class="params">n, k</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        ret += <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        n = -n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        arr.<span class="title function_">push</span>(n % k);</span><br><span class="line">        n = <span class="built_in">parseInt</span>(n / k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">        ret += arr.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> n = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">var</span> k = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回true则说明该函数功能正确</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(n.<span class="title function_">toString</span>(k) == <span class="title class_">BaseChange</span>(n, k));</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
<div class='center'>
<figure class="highlight javascript"><figcaption><span>十六进制转换</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> toHex = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(num &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        num = <span class="title class_">Math</span>.<span class="title function_">pow</span>(<span class="number">2</span>,<span class="number">32</span>) + num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">BaseChange</span>(num);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="title class_">BaseChange</span> = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="keyword">var</span> arr = [];</span><br><span class="line">    <span class="keyword">while</span> (n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(n % <span class="number">16</span>&gt;= <span class="number">10</span>)&#123;</span><br><span class="line">            arr.<span class="title function_">push</span>(<span class="title class_">String</span>.<span class="title function_">fromCharCode</span>(<span class="string">&#x27;a&#x27;</span>.<span class="title function_">charCodeAt</span>() + n % <span class="number">16</span> - <span class="number">10</span>))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            arr.<span class="title function_">push</span>(n % <span class="number">16</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        n = <span class="built_in">parseInt</span>(n / <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (arr.<span class="property">length</span>) &#123;</span><br><span class="line">        ret += arr.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
</div>
<h2 id="有效的完全平方数-x的平方根"><a class="header-anchor" href="#有效的完全平方数-x的平方根"></a><a href="https://leetcode.cn/problems/valid-perfect-square/">有效的完全平方数</a> / <a href="https://leetcode.cn/problems/sqrtx/">x的平方根</a></h2>
<p><strong>简述：</strong><br>
  ①判断一个数是否是完全平方数<br>
  ②返回非负整数x的算术平方根(取整)<br>
<strong>思路：</strong><br>
  两者皆可用双指针二分查找的方式进行。设左指针l指向0，右指针r指向输入的数字。判断有效的完全平方数就是看[0, nums]里是否有一个数target使得target<sup>2</sup>=nums; 计算平方根则是找到满足target<sup>2</sup>&lt;=nums的最大target。<br>
<strong>题解：</strong></p>
<div>
<div class='left'> 
<figure class="highlight javascript"><figcaption><span>有效的完全平方数</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">num</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> isPerfectSquare = <span class="keyword">function</span>(<span class="params">num</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, r = num;</span><br><span class="line">    <span class="keyword">var</span> ans;</span><br><span class="line">    <span class="keyword">var</span> center;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        center = <span class="built_in">parseInt</span>((l+r)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(center * center &lt;= num)&#123;</span><br><span class="line">            <span class="comment">//每次满足条件的时候，ans都需要更新</span></span><br><span class="line">            ans = center;</span><br><span class="line">            l = center + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            r = center + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans * ans == num;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<div class='right'> 
<figure class="highlight javascript"><figcaption><span>x的平方根</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">x</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> mySqrt = <span class="keyword">function</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, r = x;</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        <span class="keyword">var</span> center = <span class="built_in">parseInt</span>((l+r)/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span>(center * center &gt; x)&#123;</span><br><span class="line">            r = center - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            ans = center;</span><br><span class="line">            l = center + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div> 
</div>
<h2 id="双指针"><a class="header-anchor" href="#双指针"></a>双指针</h2>
<h3 id="排序数组中两个数字之和"><a class="header-anchor" href="#排序数组中两个数字之和"></a><a href="https://leetcode.cn/problems/kLl5u1/">排序数组中两个数字之和</a></h3>
<p><strong>简述：</strong><br>
  给定一个已按照 <strong>升序排列</strong>  的整数数组 numbers ，请你从数组中找出两个数满足相加之和等于目标数 target 。<br>
  函数应该以长度为 2 的整数数组的形式返回这两个数的下标值。numbers 的下标 从 0 开始计数 ，所以答案数组应当满足 0 &lt;= answer[0] &lt; answer[1] &lt; numbers.length。<br>
  假设数组中存在且只存在一对符合条件的数字，同时一个数字不能使用两次。<br>
<strong>思路：</strong><br>
  一开始我的想法是遍历第一个数，第二个数(target - 第一个数)则采用二分查找的方式在大于第一个数的位置寻找。后来看题解才发现双指针的巧妙方式：定义左指针指向第一个数，右指针指向最后一个数。求和，若结果小于target，则说明左指针的数小了，左指针++；反之，若结果大于target，则说明右指针的数大了，右指针--。<br>
  为什么这种方式不会漏掉解？因为最后返回的结果(numbers[i], numbers[j])中必然是 0 &lt;= i &lt;= j &lt;= numbers.length - 1; 而在移动过程中，不会有任意一个指针移动到[i, j]的范围内。<br>
<strong>题解：</strong></p>
<div>
<div class='center'>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">numbers</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number[]</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> twoSum = <span class="keyword">function</span>(<span class="params">numbers, target</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, r = numbers.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( l&lt;=r ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers[l] + numbers[r] &lt; target) &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target) &#123; </span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> [l, r]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
</div>
<h2 id="动态规划"><a class="header-anchor" href="#动态规划"></a>动态规划</h2>
<h3 id="路径的数目"><a class="header-anchor" href="#路径的数目"></a><a href="https://leetcode.cn/problems/2AoeFn/">路径的数目</a></h3>
<p><strong>简述：</strong><br>
  一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。问总共有多少条不同的路径？<br>
<strong>思路：</strong><br>
  建立一个二维数组记录从顶点到达当前位置的路径数，对于如题所述的二维网格来说，位于中间的某个格子只能从上方的相邻格子或者左边的相邻格子走过来。因此当前格子的路径数等于左边格子的路径数 + 上边格子的路径数。而对于第一行或者第一列的格子，只能由左边或者上边格子走过来，因此这些格子的路径数都是1。<br>
  而更简单的解法是利用组合数学（杨辉三角）：从(1,1)行进到(m,n)共要移动(m + n - 2)次，其中有(m-1)次是向右移动：所需次数为C(m+n-2, m-1) = (m+n-2)!/((n-1)!*(m-1)!)<br>
<strong>题解：</strong></p>
<div>
<div class='center'>
<figure class="highlight javascript"><figcaption><span>路径数目</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">m</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> uniquePaths = <span class="keyword">function</span>(<span class="params">m, n</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> path = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m; i++)&#123;</span><br><span class="line">        path.<span class="title function_">push</span>([]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">                path[i][j] = <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">                path[i][j] = path[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</span><br><span class="line">                path[i][j] = path[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                path[i][j] = path[i-<span class="number">1</span>][j] + path[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> path[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
</div>
<h3 id="爬楼梯的最少成本"><a class="header-anchor" href="#爬楼梯的最少成本"></a><a href="https://leetcode.cn/problems/GzCJIP/">爬楼梯的最少成本</a></h3>
<p><strong>简述：</strong><br>
  数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。<br>
  示例：<br>
    <strong>输入</strong>：cost = [10, 15, 20]<br>
    <strong>输出</strong>：15<br>
    <strong>解释</strong>：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。<br>
<strong>思路：</strong><br>
  登到某级台阶所花费的总体力有两种可能，要么是从前一级一步登上来，要么是从前两级两步登上来。取两者中较小的体力耗费即可。<br>
<strong>题解：</strong></p>
<div>
<div class='center'>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; cost</span><br><span class="line"> * @return &#123;number&#125;</span><br><span class="line"> */</span><br><span class="line">var minCostClimbingStairs = function(cost) &#123;</span><br><span class="line">    var costTotalArray = [];</span><br><span class="line">    costTotalArray[0] = 0;</span><br><span class="line">    costTotalArray[1] = 0;</span><br><span class="line">    for (var i = 2; i &lt;= cost.length; i++)&#123;</span><br><span class="line">        costTotalArray.push(Math.min(cost[i-1] + costTotalArray[i-1], costTotalArray[i-2] + cost[i-2]))</span><br><span class="line">    &#125;</span><br><span class="line">    return costTotalArray[cost.length]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'>
</div>
<h2 id="可被-5-整除的二进制前缀"><a class="header-anchor" href="#可被-5-整除的二进制前缀"></a><a href="https://leetcode.cn/problems/binary-prefix-divisible-by-5/">可被 5 整除的二进制前缀</a></h2>
<p><strong>简述：</strong><br>
  给定一个二进制数组 nums ( 索引从0开始 )。我们将xi 定义为其二进制表示形式为子数组 nums[0..i] (从最高有效位到最低有效位)。<br>
  例如，如果 nums =[1,0,1] ，那么 x0 = 1, x1 = 2, 和 x2 = 5。返回布尔值列表 answer，只有当 xi 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。<br>
<strong>思路：</strong><br>
  定义一个xi，每读一位数字二进制数字就是左移一位（相当于乘以2）+ 该位数字，然后除以五取余，最后<strong>令xi等于该余数</strong>（这是一个比较巧妙的思路，这样xi就不会溢出），若所得余数为0，可以向answer中压入true，反之则压入false。<br>
<strong>题解：</strong></p>
<div>
<div class='center'>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;number[]&#125; nums</span><br><span class="line"> * @return &#123;boolean[]&#125;</span><br><span class="line"> */</span><br><span class="line">var prefixesDivBy5 = function(nums) &#123;</span><br><span class="line">    var ret = []</span><br><span class="line">    var number = 0;</span><br><span class="line">    for (var i = 0; i &lt; nums.length; i++)&#123;</span><br><span class="line">        number = number * 2 + nums[i];</span><br><span class="line">        number %= 5</span><br><span class="line">        if (!number)&#123;</span><br><span class="line">            ret.push(true);</span><br><span class="line">        &#125;</span><br><span class="line">        else ret.push(false);</span><br><span class="line">    &#125;</span><br><span class="line">    return ret;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'>
</div>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Javascript</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>JS杂项知识记录</title>
    <url>/2022/09/13/js-learning/</url>
    <content><![CDATA[<h1 id="类型"><a class="header-anchor" href="#类型"></a>类型</h1>
<ul>
<li>基础数据类型<br>
<strong>最新的 ECMAScript 标准定义了 8 种数据类型,分别是</strong>
<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>bigint</code></li>
<li><code>boolean</code></li>
<li><code>null</code> (<code>typeof null</code>返回结果为object)</li>
<li><code>undefined</code></li>
<li><code>symbol</code> (ECMAScript 2016新增)</li>
</ul>
</li>
</ul>
<blockquote>
<p>所有基本类型的值都是不可改变的。但需要注意的是，基本类型本身和一个赋值为基本类型的变量的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p>
</blockquote>
<ul>
<li>引用类型
<ul>
<li><code>Object</code>（包含普通对象-Object，数组对象-Array，正则对象-RegExp，日期对象-Date，数学函数-Math，函数对象-Function）</li>
</ul>
</li>
</ul>
<p>基本数据类型会放在<b>栈</b>上，引用类型放在<b>堆</b>上</p>
<h1 id="函数的参数传递"><a class="header-anchor" href="#函数的参数传递"></a>函数的参数传递</h1>
<ul>
<li>基本数据类型的参数传递</li>
</ul>
<div>
<div class='center'>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    a++;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="title function_">fn</span>(x)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure>
可以看到传入函数<code>fn</code>的，是变量x的一个复制（值拷贝）。因此尽管函数体内部该变量发生变化，原变量x不发生改变。
</div>
<div class='clear'></div>
</div>
<ul>
<li>引用类型的参数传递</li>
</ul>
<div>
<div class='center'>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    a[<span class="number">0</span>] = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> <span class="title class_">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="title function_">fn</span>(x)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x);</span><br></pre></td></tr></table></figure>
这里传入函数的变量a是引用类型（数组对象），实际上传入参数指向了堆中相同的地址，此时函数体内部改变了堆上对象的属性，在函数外也发生改变。
</div>
<div class='clear'></div>
</div>
<h1 id="变量的作用域"><a class="header-anchor" href="#变量的作用域"></a>变量的作用域</h1>
<h2 id="局部和全局变量"><a class="header-anchor" href="#局部和全局变量"></a>局部和全局变量</h2>
<div>
<div class='center'>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> p = <span class="number">1</span>;</span><br><span class="line">    p = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;局部作用域的局部变量p:&#x27;</span> + p);</span><br><span class="line">    <span class="comment">//局部作用域的全局变量</span></span><br><span class="line">    num = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;全局作用域的全局变量p:&#x27;</span> + p);</span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;未声明在函数内部赋值的变量属于全局变量:&#x27;</span> + num)</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
</div>
<ul>
<li>局部变量只在函数内部生效</li>
<li>当局部变量与全局变量重名时，对变量的修改只对局部变量生效</li>
<li>未声明在函数内部赋值的变量属于全局变量（即函数外可调用）</li>
<li>函数的形参也是局部变量</li>
</ul>
<h2 id="作用域链"><a class="header-anchor" href="#作用域链"></a>作用域链</h2>
<div>
<div class='center'>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">2</span>;</span><br><span class="line">    <span class="title function_">fn2</span>();</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">fn2</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">fn</span>();</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
</div>
&emsp;&emsp;·内部函数访问外部变量，根据链式查找方式决定。
<h1 id="JS的预解析"><a class="header-anchor" href="#JS的预解析"></a>JS的预解析</h1>
<div>
<div class='center'>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.先向控制台打印变量，后声明该变量并赋值</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 控制台输出undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.先调用函数，后通过函数声明的方式创建函数</span></span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台输出&#x27;fn&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.以函数表达式创建函数（匿名函数）</span></span><br><span class="line"><span class="title function_">fn2</span>();</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">fn2</span>() = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 控制台报错 Uncaught TypeError: fn2 is not a function</span></span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
</div>
<p>  ·js解释器在执行js脚本时，会先进行预解析，然后进行代码执行。<br>
    (1)预解析将所有<strong>var声明</strong>的变量以及function提升至当前作用域的最前面。<br>
    (2)按照预解析后的顺序依次执行。<br>
  预解析分为变量预解析和函数预解析。<br>
    (1)变量预解析将变量的声明放在最前方。<strong>不涉及函数赋值</strong><br>
    (2)函数预解析将函数声明所创建的函数放在最前方。<strong>不涉及函数表达式创建的函数</strong></p>
<p>  因此，上面的代码实际执行顺序如下：</p>
<div>
<div class='center'>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num;</span><br><span class="line"><span class="keyword">var</span> <span class="title function_">fn2</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 此时num未赋值，因此输出undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(num);</span><br><span class="line">num = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// fn()已经声明，可以正常调用</span></span><br><span class="line"><span class="title function_">fn</span>();</span><br><span class="line"><span class="comment">// fn2 只是一个变量，还不是函数，因此fn2()语句会出错。</span></span><br><span class="line"><span class="title function_">fn2</span>();</span><br><span class="line">fn2 = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fn2&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</div>
<div class='clear'></div>
</div>]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>编程</tag>
        <tag>Javascript</tag>
        <tag>语法</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML / CSS 杂项知识记录</title>
    <url>/2022/09/22/h5-css3-learning/</url>
    <content><![CDATA[<h1 id="字体图标"><a class="header-anchor" href="#字体图标"></a>字体图标</h1>
<p>矢量绘制的小图标，以字体的形式引入方便运用于需要调整颜色/改变大小的地方(可以像文字一样调整大小和颜色)。例如以下几个图标：</p>
<div class='iconfont' style='font-size:30px;color:red;cursor: default;        
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -moz-user-select: none;
        -ms-user-select: none;
        user-select: none;'>&#xe606;&#xe607;&#xe608;&#xe609;&#xe60a;</div>
同时，为了避免复制这些字体图标粘贴到其它未设置该字体的地方导致乱码，我们可以将这里的鼠标样式设置为默认 / css禁止选择该段文本。
<h1 id="css三角形绘制"><a class="header-anchor" href="#css三角形绘制"></a>css三角形绘制</h1>
<ul>
<li>等腰三角形<div style='width:0px; height:0px; border: 20px solid transparent; border-top: 20px solid red;'></div>
如上所示，将div盒子的大小设置为0，边框border指定大小，solid，并且设定四个边其中之一即可得到此等腰三角形。
</li>
<li>直角三角形<div style='width:0px; height:0px; border-right: 20px solid transparent; border-bottom: 40px solid red;'></div>
对相邻两边的border属性进行设置，其余两边留空。
</li>
</ul>
<p><strong>自己来试一试</strong></p>
<div>
<div class='left' style='border: 1px dotted grey; position: relative; height: 180px;'>
<div style='width:0; height:0; border-top: 20px solid red;border-right:20px solid brown;border-bottom:20px solid green; border-left:20px solid lightblue; position:absolute; left:50%; top: 60px;margin-left:-20px' id='test'></div>
</div>
<div class='right' style='border: 1px dotted grey; position: relative; height: 180px;'>
<div class="slidecontainer">
  border-left: <input type="range" min="0" max="40" value="20" id="left" style="vertical-align: middle;" onchange='left_display.value=this.value'><output id='left_display' for='left'>20</output><br>
  border-right: <input type="range" min="0" max="40" value="20" id="right" style="vertical-align: middle;" onchange='right_display.value=this.value'><output id='right_display' for='right'>20</output><br>
  border-bottom: <input type="range" min="0" max="40" value="20" id="bottom" style="vertical-align: middle;" onchange='bottom_display.value=this.value'><output id='bottom_display' for='bottom'>20</output><br>
  border-top: <input type="range" min="0" max="40" value="20" id="top" style="vertical-align: middle;" onchange='top_display.value=this.value'><output id='top_display' for='top'>20</output><br>
  <button style='position:absolute; left:50%; margin-left: -40px;width:80px' onclick='changeCSS(left_display.value, right_display.value, bottom_display.value, top_display.value)'>Apply</button>
  <script>
    function changeCSS(a, b, c, d){
      var divbox = document.getElementById("test"); 
      divbox.style.borderTopWidth = d + 'px';
      divbox.style.borderBottomWidth = c + 'px';
      divbox.style.borderLeftWidth = a + 'px';
      divbox.style.borderRightWidth = b + 'px';
    }
  </script>
</div>
</div>
<div class='clear'></div>
</div>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>语法</tag>
        <tag>HTML</tag>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
